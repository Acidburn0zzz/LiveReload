// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var EventEmitter, Job, JobHandler, JobQueue, debug, iced, inspect, stringifyRequest, stringifyValue, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        ++this.count;
        return (function(_this) {
          return function() {
            var inner_params, _ref;
            inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (defer_params != null) {
              if ((_ref = defer_params.assign_fn) != null) {
                _ref.apply(null, inner_params);
              }
            }
            return _this._fulfill();
          };
        })(this);
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  EventEmitter = require('events').EventEmitter;

  inspect = require('util').inspect;

  debug = require('debug')('jobqueue');

  module.exports = JobQueue = (function(_super) {
    __extends(JobQueue, _super);

    function JobQueue() {
      this.handlers = [];
      this.idsToJobs = {};
      this.queue = [];
      this.scheduled = false;
      this.prohibition = false;
      this.runningJob = null;
    }

    JobQueue.prototype.register = function(scope, options, func) {
      var handler;
      if ((typeof func === 'undefined') && (typeof options === 'function')) {
        func = options;
        options = {};
      }
      if (typeof scope !== 'object') {
        throw new TypeError("JobQueue.register(scope, [options], func) scope arg must be an object");
      }
      if (typeof options !== 'object') {
        throw new TypeError("JobQueue.register(scope, [options], func) options arg must be an object");
      }
      if (typeof func !== 'function') {
        throw new TypeError("JobQueue.register(scope, [options], func) func arg must be a function");
      }
      handler = new JobHandler(scope, options, func);
      this.handlers.push(handler);
      return debug("Registered handler " + handler.id + " with ID keys " + (JSON.stringify(handler.idKeys)));
    };

    JobQueue.prototype.add = function(request) {
      var handler, job, priorJob;
      if (this.prohibition) {
        throw new Error("Adding new jobs during 'empty' event is not allowed");
      }
      if (handler = this.findHandler(request)) {
        job = new Job(request, handler);
        debug("Adding " + job);
        if (priorJob = this.idsToJobs[job.id]) {
          debug("Found existing " + priorJob);
          if (priorJob.handler === handler) {
            job.consume(priorJob);
            this.removeJobFromQueues(priorJob);
            debug("Merged the old job into the new one: " + job);
          } else {
            throw new Error("Attempted to add a job that matches another job with the same id, but different handler: new job " + job + ", prior job " + priorJob);
          }
        }
        this.addJobToQueue(job);
        return this.schedule();
      } else {
        throw new Error("No handlers match the added request: " + stringifyRequest(request));
      }
    };

    JobQueue.prototype.getQueuedRequests = function() {
      var job, _i, _len, _ref, _results;
      _ref = this.queue;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        job = _ref[_i];
        _results.push(job.request);
      }
      return _results;
    };

    JobQueue.prototype.checkpoint = function(func, description) {
      if (description == null) {
        description = '';
      }
      this.once('drain', (function(_this) {
        return function() {
          debug("checkpoint(" + description + ")");
          return func();
        };
      })(this));
      return this.schedule();
    };

    JobQueue.prototype.after = function(func, description) {
      if (description == null) {
        description = '';
      }
      this.once('empty', (function(_this) {
        return function() {
          debug("after(" + description + ")");
          return func();
        };
      })(this));
      return this.schedule();
    };

    JobQueue.prototype.findHandler = function(request) {
      var handler, _i, _len, _ref;
      _ref = this.handlers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        handler = _ref[_i];
        if (handler.matches(request)) {
          return handler;
        }
      }
      return null;
    };

    JobQueue.prototype.schedule = function() {
      if (this.scheduled || this.runningJob) {
        return;
      }
      this.scheduled = true;
      return process.nextTick((function(_this) {
        return function() {
          _this.scheduled = false;
          return _this.executeNextJob();
        };
      })(this));
    };

    JobQueue.prototype.executeNextJob = function() {
      var job;
      debug("executeNextJob");
      if (job = this.extractNextQueuedJob()) {
        return this.executeJob(job);
      } else {
        this.emit('drain');
        if (!this.scheduled) {
          this.prohibition = true;
          try {
            return this.emit('empty');
          } finally {
            this.prohibition = false;
          }
        }
      }
    };

    JobQueue.prototype.executeJob = function(job) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this.runningJob = job;
      this.emit('running', job);
      debug("Running " + job);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "C:\\dev\\LiveReload\\node_modules\\jobqueue\\lib\\jobqueue.iced",
            funcname: "JobQueue.executeJob"
          });
          job.handler.func.call(job, job.request, __iced_deferrals.defer({
            lineno: 143
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this.runningJob = null;
          _this.emit('complete', job);
          return _this.schedule();
        };
      })(this));
    };

    JobQueue.prototype.addJobToQueue = function(job) {
      this.queue.push(job);
      return this.idsToJobs[job.id] = job;
    };

    JobQueue.prototype.removeJobFromQueues = function(job) {
      var index;
      if ((index = this.queue.indexOf(job)) >= 0) {
        this.queue.splice(index, 1);
      }
      return delete this.idsToJobs[job.id];
    };

    JobQueue.prototype.extractNextQueuedJob = function() {
      var job;
      if (job = this.queue.shift()) {
        delete this.idsToJobs[job.id];
        return job;
      } else {
        return null;
      }
    };

    return JobQueue;

  })(EventEmitter);

  Job = (function() {
    function Job(request, handler) {
      this.request = request;
      this.handler = handler;
      this.id = this.handler.computeId(this.request);
    }

    Job.prototype.consume = function(priorJob) {
      return this.handler.merge(this.request, priorJob.request);
    };

    Job.prototype.toString = function() {
      return "Job(id = " + this.id + ", handler = " + this.handler.id + ", request = " + (stringifyRequest(this.request)) + ")";
    };

    return Job;

  })();

  JobHandler = (function() {
    function JobHandler(scope, options, func) {
      var key, value;
      this.scope = scope;
      this.func = func;
      this.idKeys = options.idKeys || ((function() {
        var _ref, _results;
        _ref = this.scope;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          _results.push(key);
        }
        return _results;
      }).call(this)).sort();
      this.id = ((function() {
        var _ref, _results;
        _ref = this.scope;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          value = _ref[key];
          _results.push("" + key + ":" + value);
        }
        return _results;
      }).call(this)).sort().join('-');
      this.merge = options.merge || this.defaultMerge;
    }

    JobHandler.prototype.matches = function(request) {
      var key, value, _ref;
      _ref = this.scope;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (request[key] !== value) {
          return false;
        }
      }
      return true;
    };

    JobHandler.prototype.computeId = function(request) {
      var key;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.idKeys;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          _results.push("" + key + ":" + request[key]);
        }
        return _results;
      }).call(this)).join('-');
    };

    JobHandler.prototype.defaultMerge = function(request, priorRequest) {
      var key, newValue, oldValue, _results;
      _results = [];
      for (key in priorRequest) {
        if (!__hasProp.call(priorRequest, key)) continue;
        oldValue = priorRequest[key];
        newValue = request[key];
        if (newValue !== oldValue) {
          if ((Array.isArray(newValue)) && (Array.isArray(oldValue))) {
            newValue.splice.apply(newValue, [0, 0].concat(__slice.call(oldValue)));
            continue;
          }
          throw new Error("No default strategy for merging key '" + key + "' of old request into new request; request id is " + request.id + ", old request is " + (stringifyRequest(priorRequest)) + ", new request is " + (stringifyRequest(request)));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return JobHandler;

  })();

  JobQueue.stringifyRequest = stringifyRequest = function(request) {
    var key, value;
    return ((function() {
      var _results;
      _results = [];
      for (key in request) {
        if (!__hasProp.call(request, key)) continue;
        value = request[key];
        _results.push("" + key + ":" + (stringifyValue(value)));
      }
      return _results;
    })()).join('-');
  };

  JobQueue.stringifyValue = stringifyValue = function(value) {
    if (typeof value === 'string') {
      return value;
    } else {
      return inspect(value);
    }
  };

}).call(this);
