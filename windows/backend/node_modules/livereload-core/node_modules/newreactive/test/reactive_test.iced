{ ok, equal, deepEqual } = require 'assert'
_ = require 'underscore'
R = require "../#{process.env.JSLIB or 'lib'}/reactive"

throws = (smt, func) ->
  require('assert').throws func, smt


Object.defineProperty R.Universe::, 'kindNames', get: ->  _.pluck(@kinds, 'kind').sort()

catchAndReturnError = (func) ->
  try func(); return null
  catch err then return err


Advise =
  before: (object, key, decorator) ->
    original = object[key]
    object[key] = (args...) ->
      decorator.call(object, args...)
      original.call(object, args...)


helpers =
  usesUniverse: ->
    beforeEach -> @universe = new R.Universe()
    afterEach  -> @universe.dispose(); delete @universe
    return this

  usesRootEntity: ->
    beforeEach ->
      @universe.define(EmptyEntity)
      @root = @universe.create('EmptyEntity')

      @performAndWait = (done, name, func) =>
        @universe.performAndWait(func, done)

    return this

  defines: (entityClasses...) ->
    beforeEach ->
      @universe.define(entityClasses)
    return this

  creates: (fieldName, kind, attributes={}) ->
    beforeEach ->
      this[fieldName] = @universe.create(kind, attributes)
    return this

  performAndWait: (name, func) ->
    beforeEach (done) ->
      @performAndWait done, name, func.bind(this)

  createsInJob: (fieldName, kind, attributes={}) ->
    helpers.performAndWait "initialize", ->
      this[fieldName] = @universe.create(kind, attributes)
    return this

  usesLog: ->
    beforeEach ->
      @log = []
      @log.equal = (expected) =>
        equal JSON.stringify(@log, null, 2), JSON.stringify(expected, null, 2)
        @log.splice(0, @log.length)
      @log.pusher = (line) =>
        return =>
          @log.push(line); undefined
      @log.wrap  = (line, func) =>
        log = @log
        return (args...) ->
          log.push line
          return func.apply(this, args)
      @log.inspectTaskEvents = (task, events) ->
        if 'finalized' in events
          task.on 'finalized', @pusher("#{task}.finalized")
        if 'completed' in events
          task.on 'completed', @pusher("#{task}.completed")
        return this
    afterEach ->
      delete @log
    return this

  inspectReads: ->
    beforeEach ->
      Advise.before @universe, 'reading', (entity, topic) => @log.push("reading #{entity._r_id} #{topic}") if @log
    return this

  inspectBroadcasts: ->
    beforeEach ->
      Advise.before @universe, 'broadcast', (entity, topic) => @log.push("change #{entity._r_id} #{topic}") if @log
    return this

  inspectSubscriptions: ->
    beforeEach ->
      Advise.before @universe, 'subscribe', (dependent, entity, topicSet) =>
        if @log
          topics = (if topicSet then Object.keys(topicSet).join(',') else 'null')
          @log.push("sub #{dependent._r_id} #{entity._r_id} #{topics}")
    return this



class EmptyEntity

class SimpleEntity_WithAutomaticalBlock
  schema:
    someValue:               { type: 'int' }

  automatically_collect_something: ->
    (@list or= []).push @someValue

class BaseEntity
  schema:
    someValue:               { type: 'int', default: 42 }

  initialize: ->
    @baseInitialized = yes

  boringMethod: ->
    24

  automatically_copy_someValue: ->
    @someValueCopy = @someValue

class DerivedEntity
  schema:
    $extends: 'BaseEntity'
    anotherValue:            { type: 'int', default: 33 }

  initialize: ->
    @derivedInitialized = yes

  veryBoringMethod: ->
    12

  automatically_copy_anotherValue: ->
    @anotherValueCopy = @anotherValue

class IncludingEntity
  schema:
    $includes: BaseEntity

class MyApp_SomeMethods
  something: (x) -> x + 1

class MyApp_OtherMethods
  another: (x) -> x * 2

class MyApp_EventCount
  schema:
    eventCount:              { type: 'int' }

class MyApp_EventCount_WithDefault
  schema:
    eventCount:              { type: 'int', default: 42 }

class MyApp_DoubleEventCount
  schema:
    doubleEventCount:        { type: 'int' }

  compute_doubleEventCount: ->
    @eventCount * 2

class MyApp_Status1
  schema:
    status:                  { type: 'string' }
  compute_status: ->
    "eventCount is #{@eventCount}"

class MyApp_Status2
  schema:
    status:                  { type: 'string' }
  compute_status: ->
    "doubleEventCount ends with #{@doubleEventCount % 10}"

class MyApp_SuperStatus
  schema:
    superStatus:             { type: 'string' }
  compute_superStatus: ->
    "(#{@status})"

class MyApp_PathCollection
  schema:
    pluginPaths:             { collection: 'list', type: 'string' }

class MyApp_RubyCollection1
  schema:
    rubies:                  { collection: 'list', type: 'LRRuby' }

class LRRuby_Basics
  schema:
    path:                    { type: String }

class LRRuby_Version
  schema:
    version:                 { type: String }

  compute_version: (callback) ->
    setTimeout =>
      if @path is '/usr/bin/ruby'
        callback(null, "1.8.7")
      else
        callback(null, "1.9.3")
    , 5

class MyApp_SystemRubies
  schema:
    systemRubies:            { collection: 'list', type: 'LRRuby' }

  compute_systemRubies: (callback) ->
    process.nextTick ->
      callback null, [
        { path: '/usr/bin/ruby' }
        { path: '/usr/local/bin/ruby' }
        { path: '~/.rvm/rubies/rvm-ruby-1.9.2/bin/ruby' }
      ]

LittleQuacker =
  name: 'LittleQuacker'
  duck:
    quacks: yes
    swims:  no

class Tom_InSouthboundDuckling
  schema:
    southernFriedDuck:       { type: 'LittleQuacker?' }

  hunger: ->
    100 - (@southernFriedDuck?.calories or 0)


class Jerry_MutualRef
  schema:
    enemy:                   { type: 'Tom?' }

class Tom_MutualRef
  schema:
    enemy:                   { type: 'Jerry?' }



describe 'R', ->

  it "exports VERSION", ->
    ok R.VERSION.match /^\d+\.\d+\.\d+$/


describe 'R.Universe', ->
  helpers.usesUniverse()

  describe ".uniqueId(className, [detail]) return value", ->
    it "is a string", ->
      equal typeof(@universe.uniqueId('Foo')), 'string'
    it "is composed of the prefix followed by some digits", ->
      ok @universe.uniqueId('Foo').match /^Foo\d+$/
    it "is different on each call", ->
      ok @universe.uniqueId('Foo') != @universe.uniqueId('Foo')

    describe "(when the <detail> argument is specified)", ->
      it "has an alphanumeric representation of <detail> appended to the id", ->
        id = @universe.uniqueId('Foo', 'Bar Boz')
        ok id.match(/^Foo\d+_Bar_Boz$/), "id '#{id}' does not match"

  describe '#define(klass)', ->

    describe "given a regular class", ->
      helpers.defines(EmptyEntity)

      it "defines a kind matching the given class name", ->
        deepEqual @universe.kindNames, ['EmptyEntity']

      it "adds the given class to the list of the kind's mixins", ->
        deepEqual @universe.kinds.EmptyEntity.klasses, [EmptyEntity]

    describe "given a class with a two-part name like Foo_Bar", ->
      beforeEach -> @universe.define(MyApp_SomeMethods)

      it "uses only the first part as the entity kind", ->
        deepEqual @universe.kindNames, ['MyApp']

    describe "given multiple classes for the same entity", ->
      beforeEach -> @universe.define(MyApp_SomeMethods)
      beforeEach -> @universe.define(MyApp_OtherMethods)

      it "merges them into a single entity kind", ->
        deepEqual @universe.kindNames, ['MyApp']


  describe '#create(kind, [attributes])', ->

    describe "given a valid kind", ->
      helpers.defines(MyApp_SomeMethods).creates('entity', 'MyApp')

      it "returns a new entity of that kind", ->
        ok @entity.isReactiveEntity
        equal @entity.kind, 'MyApp'

    describe "given an unknown kind", ->
      beforeEach -> @err = catchAndReturnError => @universe.create('NonExistent')
      it "throws an error", ->
        equal @err.message, "R.create: unknown entity kind 'NonExistent'"


describe 'R.Entity', ->
  helpers.usesUniverse().usesRootEntity()


  describe ".constructor.name", ->
    helpers.defines(MyApp_SomeMethods).creates('entity', 'MyApp')
    it "matches entity kind", ->
      equal @entity.constructor.name, 'MyApp'


  describe "composed of two classes", ->
    helpers.defines(MyApp_SomeMethods, MyApp_OtherMethods).creates('entity', 'MyApp')
    it "has the methods defined in both classes", ->
      equal @entity.something(10), 11
      equal @entity.another(10), 20


  describe "with a magical automatically_ block", ->
    helpers.defines(SimpleEntity_WithAutomaticalBlock).createsInJob('entity', 'SimpleEntity', someValue: 42)
    it "runs the block after entity creation", ->
      deepEqual @entity.list, [42]

    describe "after the block's dependencies are updated", ->
      helpers.performAndWait "update someValue", ->
        @entity.someValue = 33
      it "reruns the block after entity creation", ->
        deepEqual @entity.list, [42, 33]


  describe "that extends another entity", ->
    helpers.defines(BaseEntity, DerivedEntity).createsInJob('entity', 'DerivedEntity')

    it "has its own initializers invoked", ->
      ok @entity.derivedInitialized

    it "inherits the base entity's initializers", ->
      ok @entity.baseInitialized

    it "has the derived entity's attributes", ->
      equal @entity.anotherValue, 33

    it "inherits the base entity's attributes", ->
      equal @entity.someValue, 42

    it "has the derived entity's methods", ->
      equal @entity.veryBoringMethod(), 12

    it "inherits the base entity's methods", ->
      equal @entity.boringMethod(), 24

    it "runs the derived entity's automatic blocks", ->
      equal @entity.anotherValueCopy, 33

    it "inherits the base entity's automatic blocks", ->
      equal @entity.someValueCopy, 42


  describe "that includes another entity", ->
    helpers.defines(IncludingEntity).createsInJob('entity', 'IncludingEntity')

    it "obtains the included entity's initializers", ->
      ok @entity.baseInitialized

    it "obtains the included entity's attributes", ->
      equal @entity.someValue, 42

    it "obtains the included entity's methods", ->
      equal @entity.boringMethod(), 24

    it "obtains the included entity's automatic blocks", ->
      equal @entity.someValueCopy, 42


  describe "that references a non-existent  entity", ->
    it "can be defined", ->
      @universe.define(Tom_MutualRef)

    it "cannot be instantiated", ->
      @universe.define(Tom_MutualRef)
      throws /Unknown type/, =>
        tom = @universe.create('Tom')


  describe "with a cyclic reference to another entity", ->
    it "can be defined and instantiated", ->
      @universe.define(Tom_MutualRef, Jerry_MutualRef)
      tom = @universe.create('Tom')
      jerry = @universe.create('Jerry')



describe 'R.Entity attribute', ->
  helpers.usesUniverse().usesLog()

  describe "(a boring regular one)", ->
    helpers.defines(MyApp_EventCount).creates('entity', 'MyApp', eventCount: 10)

    it "can be initialized by passing a value into constructor", ->
      equal @entity.eventCount, 10

    describe "when read via .get(attr)", ->
      helpers.inspectReads()
      beforeEach -> @value = @entity.get('eventCount')

      it "returns the current value", ->
        equal @value, 10

      it "records the dependency", ->
        @log.equal ["reading MyApp1 eventCount"]

    it "can be read directly", ->
      equal @entity.eventCount, 10

    it "can be set via .set()", ->
      @entity.set('eventCount', 20)
      equal @entity.eventCount, 20

    describe "when set directly", ->
      helpers.inspectBroadcasts()
      beforeEach ->
        @entity.eventCount = 20
      it "updates the value", ->
        @entity.eventCount = 20
        equal @entity.eventCount, 20
      it "broadcasts a change event", ->
        @log.equal ["change MyApp1 eventCount"]

    describe 'when set to the same value', ->
      helpers.inspectBroadcasts()
      beforeEach ->
        @entity.eventCount = 10
      it "does not broadcast a change event", ->
        @log.equal []


  describe "not defined by the schema", ->
    helpers.defines(MyApp_EventCount).creates('entity', 'MyApp', eventCount: 10)

    it "throws an error when reading via #get", ->
      equal((catchAndReturnError => @entity.get('missingAttr'))?.message, "Unknown attribute 'missingAttr'")

    it "throws an error when writing via #set", ->
      equal((catchAndReturnError => @entity.set('missingAttr', 20))?.message, "Unknown attribute 'missingAttr'")


  describe "with a default value", ->
    helpers.usesRootEntity().defines(MyApp_EventCount_WithDefault).creates('entity', 'MyApp')
    it "is initially set to the provided default value", ->
      equal @entity.eventCount, 42


  describe "with a type", ->
    helpers.usesRootEntity().defines(MyApp_EventCount).creates('entity', 'MyApp')
    it "is initially set to the type-specific default value", ->
      equal @entity.eventCount, 0

    describe "when assigned a value of a different compatible type", ->
      it "coerces the value into the correct type", ->
        @entity.eventCount = "11"
        equal @entity.eventCount, 11
        equal (typeof @entity.eventCount), 'number'

    describe "when assigned a value of an incompatible type", ->
      it "throws an error", ->
        throws /expected an integer/, =>
          @entity.eventCount = []
        throws /expected an integer/, =>
          @entity.eventCount = null


  describe "with a duck type", ->
    helpers.defines(LittleQuacker, Tom_InSouthboundDuckling).creates('tom', 'Tom')

    describe "when provided with the the right duck", ->
      it "eats it promptly", ->
        @tom.southernFriedDuck = { quacks: yes, swims: no, calories: 100 }
        equal @tom.hunger(), 0

    describe "when provided with an ignited bomb", ->
      it "chokes and fails to eat", ->
        throws /expected a LittleQuacker-like object/, =>
          # 1 kg TNT generates exactly 1 Mcal energy; assuming a 250g duckling and a weight match here
          @tom.southernFriedDuck = { boomIn: 3, calories: 250000 }
        equal @tom.hunger(), 100


  describe "with a compute function", ->
    helpers.usesRootEntity().defines(MyApp_EventCount, MyApp_Status1)
    helpers.createsInJob('entity', 'MyApp', eventCount: 10)

    it "is initially set to the default value", ->
      equal @universe.create('MyApp', eventCount: 10).status, ""

    it "is eventually set to the computed value", ->
      equal @entity.status, "eventCount is 10"

    describe "when the source value is updated", ->
      helpers.performAndWait "set eventCount", ->
        @entity.eventCount = 20

      it "the computed values is also eventually updated", ->
        equal @entity.status, "eventCount is 20"

  describe "with an async compute function", ->
    helpers.usesRootEntity().defines(LRRuby_Basics, LRRuby_Version)
    helpers.createsInJob('entity', 'LRRuby', path: '/usr/bin/ruby')

    it "is initially set to the default value", ->
      equal @universe.create('LRRuby', path: '/usr/bin/ruby').version, ""

    it "is eventually set to the computed value", ->
      equal @entity.version, "1.8.7"

    describe "when the source value is updated", ->
      helpers.performAndWait "update ruby.path", ->
        @entity.path = '/usr/local/bin/ruby'

      it "the computed values is also eventually updated", ->
        equal @entity.version, "1.9.3"

  describe "with a chain of dependent computed attributes", ->
    helpers.usesRootEntity().defines(MyApp_EventCount, MyApp_DoubleEventCount, MyApp_SuperStatus, MyApp_Status2)
    helpers.createsInJob('entity', 'MyApp', eventCount: 14)

    it "all computed attributes are eventually set to the final values", ->
      equal @entity.doubleEventCount, 28
      equal @entity.status, "doubleEventCount ends with 8"
      equal @entity.superStatus, "(doubleEventCount ends with 8)"

    describe "when the source attribute is updated", ->
      helpers.inspectBroadcasts()
      helpers.performAndWait "set eventCount", ->
        @entity.eventCount = 16

      it "the computed attributes are all eventually updated", ->
        equal @entity.doubleEventCount, 32
        equal @entity.status, "doubleEventCount ends with 2"
        equal @entity.superStatus, "(doubleEventCount ends with 2)"

      it "change events are broadcasted for the source and computed attributes", ->
        @log.equal ["change MyApp1 eventCount", "change MyApp1 doubleEventCount", "change MyApp1 status", "change MyApp1 superStatus"]

    describe "when the source attribute is set to the same value", ->
      helpers.inspectBroadcasts()
      helpers.performAndWait "set eventCount", ->
        @entity.eventCount = 14
      it "no change events are broadcasted", ->
        @log.equal []

    describe "when the source attribute is updated, but intermediate attribute value stays the same", ->
      helpers.inspectBroadcasts()
      helpers.performAndWait "set eventCount", ->
        @entity.eventCount = 9
      it "no change events are broadcasted for unmodified values", ->
        @log.equal ["change MyApp1 eventCount", "change MyApp1 doubleEventCount"]


describe "R.Task", ->
  helpers.usesUniverse().usesRootEntity().usesLog()

  describe "with ONESHOT type, sync function and no subtasks", ->
    beforeEach ->
      @task1 = new R.Task(@root, new R.TaskDef(@universe, 'smt', R.TaskDef.ONESHOT, @log.pusher("RTask1_smt.run")))
      @log.inspectTaskEvents(@task1, ['completed', 'finalized'])

    it "reports completion and finalization", (done) ->
      await @task1.schedule().waitFinalized(defer())
      @log.equal [
        'RTask1_smt.run'
        'RTask1_smt.completed'
        'RTask1_smt.finalized'
      ]
      done()

  describe "with ONESHOT type, sync function and a subtask", ->
    beforeEach ->
      func1 = =>
        @log.push "RTask1_parent.start"
        @task2.schedule()
        @log.push "RTask1_parent.end"

      @task1 = new R.Task(@root, new R.TaskDef(@universe, 'parent', R.TaskDef.ONESHOT, func1, multiuse: no, reactive: no))
      @task2 = new R.Task(@root, new R.TaskDef(@universe, 'child', R.TaskDef.ONESHOT, @log.pusher("RTask2_child.run"), multiuse: no, reactive: no))
      @log.inspectTaskEvents(@task1, ['completed', 'finalized'])
        .inspectTaskEvents(@task2, ['completed', 'finalized'])

    it "reports parent task completion, then subtask completion/finalization, then parent task finalization", (done) ->
      await @task1.schedule().waitFinalized(defer())
      @log.equal [
        'RTask1_parent.start'
        'RTask1_parent.end'
        'RTask1_parent.completed'
        'RTask2_child.run'
        'RTask2_child.completed'
        'RTask2_child.finalized'
        'RTask1_parent.finalized'
      ]
      done()

  describe "with AUTOREPEAT type and a sync function that loves to change its dependencies", ->
    helpers.inspectSubscriptions().defines(MyApp_EventCount, MyApp_DoubleEventCount, MyApp_Status1).creates('entity', 'MyApp', eventCount: 10)

    func = ->
      for key in @keys
        dummy = @entity[key]

    beforeEach ->
      @keys = ['eventCount', 'status']
      @task1 = new R.Task(@root, new R.TaskDef(@universe, 'smt', R.TaskDef.AUTOREPEAT, func.bind(@)))

    it "subscribes to the initial set topics", (done) ->
      await @task1.on 'finalized', defer()
      @log.equal [
        'sub RTask1_compute_doubleEventCount MyApp1 eventCount'
        'sub RTask2_compute_status MyApp1 eventCount'
        'sub RTask3_smt MyApp1 eventCount,status'
      ]
      done()

    describe "when a dependency is removed", ->
      helpers.performAndWait "update eventCount", ->
        @keys = ['eventCount']
        @entity.eventCount = 11
      it "resubscribes to the new set of topics", ->
        @log.equal [
          'sub RTask1_compute_doubleEventCount MyApp1 eventCount'
          'sub RTask2_compute_status MyApp1 eventCount'
          'sub RTask3_smt MyApp1 eventCount,status'

          'sub RTask1_compute_doubleEventCount MyApp1 eventCount'
          'sub RTask2_compute_status MyApp1 eventCount'
          'sub RTask3_smt MyApp1 eventCount'
        ]

    describe "when a dependency is added", ->
      helpers.performAndWait "update eventCount", ->
        @keys = ['eventCount', 'doubleEventCount']
        @entity.eventCount = 12
      it "resubscribes to the new set of topics", ->
        @log.equal [
          'sub RTask1_compute_doubleEventCount MyApp1 eventCount'
          'sub RTask2_compute_status MyApp1 eventCount'
          'sub RTask3_smt MyApp1 eventCount,status'

          'sub RTask1_compute_doubleEventCount MyApp1 eventCount'
          'sub RTask2_compute_status MyApp1 eventCount'
          'sub RTask3_smt MyApp1 eventCount,doubleEventCount'
        ]


  describe "with AUTOREPEAT type, sync function and no subtasks", ->
    helpers.defines(MyApp_EventCount).creates('entity', 'MyApp', eventCount: 10)

    func = ->
      @log.push "RTask1_smt.run eventCount=#{@entity.eventCount}"

    beforeEach ->
      @task1 = new R.Task(@root, new R.TaskDef(@universe, 'smt', R.TaskDef.AUTOREPEAT, func.bind(@)))
      @log.inspectTaskEvents(@task1, ['completed', 'finalized'])

    it "reports completion and finalization", (done) ->
      await @task1.on 'finalized', defer()
      @log.equal [
        'RTask1_smt.run eventCount=10'
        'RTask1_smt.completed'
        'RTask1_smt.finalized'
      ]
      done()

    it "accumulates dependencies when reading an entity", ->
      await @task1.on 'finalized', defer()

      deps = @task1.completedInvocation._topicsByDepId
      deepEqual Object.keys(deps).sort(), ['MyApp1']
      deepEqual Object.keys(deps.MyApp1).sort(), ['eventCount']

    it "runs again when dependencies are updated", (done) ->
      await @task1.on 'finalized', defer()

      await @performAndWait defer(), "update eventCount", =>
        @entity.eventCount = 20

      @log.equal [
        'RTask1_smt.run eventCount=10'
        'RTask1_smt.completed'
        'RTask1_smt.finalized'
        'RTask1_smt.run eventCount=20'
        'RTask1_smt.completed'
        'RTask1_smt.finalized'
      ]
      done()

  describe "with ONESHOT type and a failing sync function", ->
    beforeEach ->
      @task1 = new R.Task(@root, new R.TaskDef(@universe, 'smt', R.TaskDef.ONESHOT, (-> throw new Error 'ETEST')))
      @log.inspectTaskEvents(@task1, ['completed', 'finalized'])

    it "reports a failed completion", (done) ->
      await @task1.schedule().waitCompleted(defer())
      equal "#{@task1.lastError}", "Error: ETEST"
      done()


describe "R.Collection", ->
  helpers.usesUniverse().usesRootEntity().usesLog()
    .defines(LRRuby_Basics)

  describe 'basic functionality', ->
    helpers.defines(MyApp_RubyCollection1).creates('entity', 'MyApp')

    it "works fine for a proof of concept", (done) ->
      equal typeof(@entity.rubies), 'object'
      ok @entity.rubies instanceof R.ListCollection
      equal @entity.rubies.all.length, 0

      ruby = @universe.create('LRRuby')
      @entity.rubies.push(ruby)
      equal @entity.rubies.all.length, 1

      task = new R.Task @root, new R.TaskDef @universe, "Add Ruby", R.TaskDef.AUTOREPEAT, =>
        @entity.rubies.push(ruby)
        equal @entity.rubies.all.length, 2
      await task.schedule().waitFinalized defer()

      keys = Object.keys(@entity.rubies._queries)
      equal keys.length, 1, "Wrong number of subscribed queries (#{keys.length} instead of 1), actual subscribed IDs: #{JSON.stringify keys}"

      task.dispose()

      keys = Object.keys(@entity.rubies._queries)
      equal keys.length, 0, "Wrong number of subscribed queries (#{keys.length} instead of 0), actual subscribed IDs: #{JSON.stringify keys}"

      done()

  describe "computed source collections", ->
    helpers.defines(MyApp_SystemRubies).createsInJob('entity', 'MyApp')

    it "work", (done) ->
      equal @entity.systemRubies.all.length, 3
      equal @entity.systemRubies.all[0].constructor.name, 'LRRuby'
      equal @entity.systemRubies.all[1].constructor.name, 'LRRuby'
      equal @entity.systemRubies.all[2].constructor.name, 'LRRuby'
      equal @entity.systemRubies.all[0].path, '/usr/bin/ruby'
      equal @entity.systemRubies.all[1].path, '/usr/local/bin/ruby'
      done()
