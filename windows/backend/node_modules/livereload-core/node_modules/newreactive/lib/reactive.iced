_ = require 'underscore'
debug = require('debug')('reactive')
{EventEmitter} = require 'events'
Domain = require 'domain'
TypeTraits = require './types'


module.exports = R =
  VERSION: '0.0.0'


# For convenience, entities support magic method names like `get_myattr`,
# which are automatically converted into options of the corresponding attributes.
# To help catch typos, an error is thrown if the attribute is not already defined.
# Here, `%` stands for the attribute name.
MAGIC_METHODS =
  getter: 'get_%'
  setter: 'set_%'
  compute: 'compute_%'
  initializer: 'initialize_%'


# Creates an empty subclass of the given superclass, with `.constructor.name` returning the given name.
createNamedSubclass = (name, superclass) ->
  if false
    # This would be a sane way to do this if Function.name was assignable under V8.
    class subclass extends superclass
    subclass.name = name
  else
    # The insane way to create a class.
    global.REACTIVE_CLASS_CREATION_HACK = superclass
    subclass = eval("(function(superclass) { return function #{name}() { superclass.apply(this, arguments); }; })(global.REACTIVE_CLASS_CREATION_HACK);")
    delete global.REACTIVE_CLASS_CREATION_HACK
    `__extends(subclass, superclass);`  # HACK: reuse CoffeeScript's internal method
  return subclass


# A better typeOf that recognizes arrays and null values
$typeOf = (val) ->
  type = typeof val
  if type is 'object'
    if !val?
      'null'
    else if Array.isArray(val)
      'array'
    else
      'object'
  else
    type


assertKeys = (options, mandatoryKeys, optionalKeys, context) ->
  actualKeys  = Object.keys(options)
  allowedKeys = mandatoryKeys.concat(optionalKeys)

  missing = _.difference(mandatoryKeys, actualKeys)
  extra   = _.difference(actualKeys, allowedKeys)

  if missing.length > 0
    throw new Error "Missing mandatory key(s) #{missing.join(', ')} in #{context}"
  if extra.length > 0
    throw new Error "Unsupported key(s) #{extra.join(', ')} in #{context}"


R.kindFromClass = (klass) ->
  # We rely on Function::name, which is a non-standard property supported by everyone except IE
  # (and can be emulated by parsing Function::toString if necessary).
  unless klass.name
    throw new Error "R requires entity classes to have a non-empty 'name'"

  # Entity name ends with the first underscore. Everything else is a SmallTalk/ObjC-style ‘category name’,
  # or a ‘mixin name’ if you will.
  return klass.name.replace(/_.*$/, '')


# A top-level context that contains all reactive stuff.
R.Universe = class RUniverse
  # Assign a unique ID to each Universe to help debugging tests (which typically create a new universe for each test).
  _nextUniverseId = 1

  constructor: ->
    @_id = "RUniverse" + (_nextUniverseId++)
    @_nextIdPerClass = {}
    @kinds = {}
    @ducks = {}

    # A domain for generic callbacks, to be used when one needs to escape from other domains.
    @callbackDomain = Domain.create()

  # For debugging only.
  toString: -> @_id

  # Initiate a singularity.
  dispose: ->


  # Generate a human-friendly unique id.
  #
  # A simple auto-incremented number would suffice here. However, for testing
  # and debugging purposes, we choose to:
  #
  # * use class name as a prefix
  # * scope autoincremented numbers to R.Universe (so that tests can rely on stable IDs)
  # * optionally append a user-defined suffix
  uniqueId: (className='', detail) ->
    detail = if detail then ('_' + detail).replace(/[^0-9a-zA-Z]+/g, '_') else ''

    @_nextIdPerClass[className] or= 1
    ordinal = @_nextIdPerClass[className]++

    "#{className}#{ordinal}#{detail}"


  # Universal definition method
  define: (args...) ->
    if args.length is 0
      throw new Error "R.Universe.define requires an argument"

    for arg, index in args
      @_defineMany arg, "arguments[#{index}]"

  # A recursive worker function that flattens the argument list, keeping track of the context for error messages
  _defineMany: (arg, context) ->
    switch type = $typeOf(arg)
      when 'object'
        @_defineOne(arg, context)
      when 'function'
        @_defineOne({ klass: arg }, context)
      when 'array'
        for item, index in arg
          @_defineMany(item, "#{context}[#{index}]")
      else
        throw new Error "R.Universe.define: invalid type '#{type}' for #{context}"

  _defineOne: (options, context) ->
    if options.duck
      @_defineDuck(options, context)
    else if options.klass
      @_defineMixin(options, context)
    else
      throw new Error "R.Universe.define: invalid option keys #{JSON.stringify Object.keys(options)} in #{context}"

  _defineDuck: (options, context) ->
    assertKeys options, ['name', 'duck'], [], "R.Universe.define, #{context}, recognized as duck type definition"
    @ducks[options.name] = new RDuckType(options.name, options.duck)

  _defineMixin: (options, context) ->
    assertKeys options, ['klass'], [], "R.Universe.define, #{context}, recognized as mixin definition"

    kind = R.kindFromClass(options.klass)

    # We may have multiple classes for the same entity, they will be all merged together (kinda like Ruby modules).
    if @kinds.hasOwnProperty(kind)
      schema = @kinds[kind]
    else
      schema = @kinds[kind] = new REntitySchema(this, kind)
    schema.addClass options.klass

    return schema

  findEntityKind: (kind) ->
    if @kinds.hasOwnProperty(kind) then @kinds[kind] else null

  resolveEntityKind: (kind) ->
    @findEntityKind(kind) or throw new Error "Unknown kind '#{kind}'"


  # Create a new entity of the specified kind.
  create: (kind, attributes={}) ->
    # TODO: legacy code support; remove/rework later
    if typeof kind is 'function'
      legacyClass = kind
      kind = legacyClass.name
      unless @kinds.hasOwnProperty(kind)
        @define(legacyClass)

    schema = @findEntityKind(kind) or throw new Error "R.create: unknown entity kind '#{kind}'"
    return schema.create(this, attributes)


  reading: (entity, topic) ->
    # debug "#{this}: reading #{entity}.#{topic}, currentTask = #{@currentTask}"
    unless entity._r_id
      throw new Error "RUniverse.reading: entity must have _r_id"
    if task = @currentTask
      task._r_reading(entity, topic)

  broadcast: (entity, topic) ->
    # debug "#{this}: change #{entity}.#{topic}"
    unless entity._r_id
      throw new Error "RUniverse.broadcast: entity must have _r_id"
    for own dependentId, dependent of entity._r_subscribers
      dependent._r_changed(entity, topic)

  # Unsubscribes the given dependent from this entity's notifications and then,
  # if topicSet is provided, resubscribes to the given list of topics.
  subscribe: (dependent, entity, topicSet) ->
    unless dependent._r_id
      throw new new Error "EINVAL: dependent must have _r_id"

    topicSetKeys = (if topicSet then Object.keys(topicSet) else null)
    # debug "#{this}: subscribing #{dependent} to #{entity}, topic set #{JSON.stringify topicSetKeys}"

    wasEmpty = (Object.keys(entity._r_subscribers).length is 0)
    if topicSet and Object.keys(topicSet).length > 0
      entity._r_subscribers[dependent._r_id] = dependent
    else
      delete entity._r_subscribers[dependent._r_id]
    isEmpty = (Object.keys(entity._r_subscribers).length is 0)

    if wasEmpty != isEmpty
      if isEmpty
        entity._r_subscription_ended?()
      else
        entity._r_subscription_started?()


  Object.defineProperty @::, 'currentTask', get: ->
    Domain.active?._r_task

  # TODO.
  enqueue: (taskDef, func) ->
    if typeof func isnt 'function'
      throw new Error "R.Universe.enqueue: func is not a function"
    @callbackDomain.run ->
      process.nextTick func


  performAndWait: (func, done) ->
    @dummyEntity or= @create(RDummyEntity)

    name = func.name or "Universe.performAndWait"

    taskDef = new R.TaskDef this, name, R.TaskDef.ONESHOT, (-> func.call(this)), autodispose: yes

    task = new R.Task @dummyEntity, taskDef
    task.schedule().waitFinalized(done)


  # Implementation of TypeResolver for types.coffee.

  resolveClassReference: (name, context) =>
    if @ducks.hasOwnProperty(name)
      return @ducks[name]
    else if kind = @findEntityKind(name)
      return kind
    else
      throw new Error "Unknown type or entity kind name: '#{name}' in #{context}"


# Stores all the information known about a specific kind (by a specific universe).
class REntitySchema
  isTypeDescriptor: yes
  isEntityTypeDescriptor: yes

  constructor: (@universe, @kind) ->
    @_r_id = @kind  # entity kinds must be unique within a Universe, so safe to use as a unique id
    @klasses = []

    @superSchemas = []
    @_ownAttributeSchemas = {}
    @automaticBlockTaskDefs = []
    @_instanceMethods = {}

    @_frozen = no

    @_hooks = {}
    # array, in DFS visitation order (i.e. a preordering of the ancestry graph)
    @_ancestorSchemas = null
    @_ancestorSchemasByKindName = null
    @_attributeSchemas = null

  # For debugging only.
  toString: -> "REntitySchema(#{@kind})"

  addClass: (klass) ->
    throw new Error "#{this}: cannot add a mixin to a frozen entity" if @_frozen

    if @klasses.indexOf(klass) < 0
      @klasses.push klass

      if klass.prototype.__proto__
        unless klass.prototype.__proto__.constructor is Object
          throw new Error "Entity inheritance must be specified via $extends, not by actually inheriting a mixin class in #{this}, class #{klass.name}"

      # TODO: maybe we want to avoid copying magic methods here?
      for own key, value of klass.prototype when key != 'schema'
        @_instanceMethods[key] = value

      @_handleEntityWideMagicMethods(klass.prototype)

      # `klass::schema` looks nicer in CoffeeScript, but `klass.schema` makes more sense,
      # so we support both
      @_addSchema(klass.schema or klass::schema or {}, klass.prototype, ["mixin class #{klass.name}"])

  create: (owner, attributes) ->
    @_freeze() unless @_frozen
    return new @EntityClass(owner, @kind, attributes)


  initialize: (entity, attributes) ->
    @_freeze() unless @_frozen

    for own attrName, attr of @_attributeSchemas
      attr.initialize(entity, attributes)

    @hook 'initialize', entity, attributes

    for entitySchema in @_ancestorSchemas
      entitySchema._initializeAutomaticTasks(entity)

  _initializeAutomaticTasks: (entity) ->
    for taskDef in @automaticBlockTaskDefs
      new R.Task(entity, taskDef)


  hook: (methodName, entity, args...) ->
    unless @_hooks.hasOwnProperty(methodName)
      funcs = []
      for entitySchema in @_ancestorSchemas
        for mixin in entitySchema.klasses
          if mixin::.hasOwnProperty(methodName)
            funcs.push(mixin::[methodName])
      @_hooks[methodName] = funcs

    for func in @_hooks[methodName]
      func.apply(entity, args)


  isKindOrSubclass: (kind) ->
    return @_ancestorSchemasByKindName.hasOwnProperty(kind)


  extend: (kind) ->
    superSchema = @universe.resolveEntityKind(kind)

    throw "#{this}: cannot add a superclass to a frozen entity" if @_frozen

    unless @superSchemas.indexOf(superSchema) >= 0
      @superSchemas.push superSchema


  _freeze: ->
    return if @_frozen
    @_frozen = yes
    @_computeAncestryChain()
    @_computeMergedAttributeSet()
    @_freezeAttributes()
    @_buildModelClass()

    # if @_ancestorSchemas.length > 1
    #   debug "#{this}._ancestorSchemas = #{_.pluck(@_ancestorSchemas, 'kind').join(', ')}"
    #   debug "#{this}._attributeSchemas = #{Object.keys(@_attributeSchemas).join(', ')}"

  _computeAncestryChain: ->
    @_ancestorSchemas = []
    @_computeAncestryChain_dfs(@_ancestorSchemas, {})

    @_ancestorSchemasByKindName = {}
    for schema in @_ancestorSchemas
      @_ancestorSchemasByKindName[schema.kind] = schema

  _computeAncestryChain_dfs: (ancestorSchemas, visitedEntitySchemas) ->
    visitedEntitySchemas[@_r_id] = yes
    ancestorSchemas.push this

    for superSchema in @superSchemas when !visitedEntitySchemas[superSchema._r_id]
      superSchema._computeAncestryChain_dfs(ancestorSchemas, visitedEntitySchemas)
    undefined

  _computeMergedAttributeSet: ->
    @_attributeSchemas = {}
    for schema in @_ancestorSchemas
      for own k, attrSchema of schema._ownAttributeSchemas
        unless @_attributeSchemas.hasOwnProperty(attrSchema.name)
          @_attributeSchemas[attrSchema.name] = attrSchema
    undefined

  _freezeAttributes: ->
    for own key, attrSchema of @_attributeSchemas
      attrSchema.freeze()
    undefined

  _buildModelClass: ->
    @EntityClass = createNamedSubclass(@kind, REntity)
    @EntityClass::schema = @EntityClass.schema = this
    @EntityClass::universe = @EntityClass.universe = @universe

    for schema in @_ancestorSchemas
      for own key, value of schema._instanceMethods
        unless @EntityClass::.hasOwnProperty(key)
          @EntityClass::[key] = value

    for own k, attrSchema of @_attributeSchemas
      attrSchema.implement(@EntityClass::)


  hasAttribute: (name) ->
    @_freeze() unless @_frozen
    @_attributeSchemas.hasOwnProperty(name)

  _handleEntityWideMagicMethods: (prototype) ->
    for own key, value of prototype
      if m = key.match /^automatically_(.*)$/
        @automaticBlockTaskDefs.push new R.TaskDef(@universe, m[1], R.TaskDef.AUTOREPEAT, value)


  _addSchema: (schema, prototype, errorContext) ->
    for own key, value of schema
      if key[0] is '$'
        @_handleSpecialSchemaKey(key, value, errorContext)
      else
        @_defineAttribute key, value, prototype
    undefined

  _defineAttribute: (attrName, attrOptions, prototype) ->
    # Convert magic methods into options.
    for own optionsKey, methodName of MAGIC_METHODS
      @_convertMethodIntoOption prototype, attrOptions, methodName.replace('%', attrName), optionsKey

    @_addAttribute new RAttributeSchema(this, attrName, attrOptions)

  _convertMethodIntoOption: (prototype, options, methodName, optionsKey) ->
    if prototype.hasOwnProperty(methodName)
      options[optionsKey] = prototype[methodName]
      delete prototype[methodName]

  _handleSpecialSchemaKey: (key, value, errorContext) ->
    errorContext = errorContext.concat(["schema.#{key}"])
    switch key
      when '$extends' then @_handleExtendsKey(value, errorContext)
      when '$includes' then @_handleIncludesKey(value, errorContext)
      else throw new Error "#{this}: unsupported special key #{key}"

  _handleExtendsKey: (value, errorContext) ->
    if typeof value is 'string'
      value = [value]

    for item in value
      unless typeof item is 'string'
        throw new Error("Invalid superclass '#{typeof item}', expected a kind name (string) in #{errorContext.join(', ')}")
      @extend(item)

  _handleIncludesKey: (value, errorContext) ->
    if typeof value is 'function'
      value = [value]

    for item in value
      unless typeof item is 'function'
        throw new Error("Invalid mixin '#{typeof item}', expected a mixin class (a function) in #{errorContext.join(', ')}")
      @addClass(item)

  _addAttribute: (attrSchema) ->
    @_ownAttributeSchemas[attrSchema.name] = attrSchema


  # Type descriptor implementation.

  coerce: (value) ->
    if value?
      unless typeof value is 'object'
        throw new Error "Invalid #{typeof value} value, expected #{@kind} entity"
      unless value.isReactiveEntity
        throw new Error "Invalid #{value.constructor.name} value, expected #{@kind} entity"
      unless value.isKindOrSubclass(@kind)
        throw new Error "Invalid #{value.kind} entity, expected #{@class.name}"
    value

  defaultValue: ->
    throw new Error "Type #{this} does not have a default value"


class RAttributeSchema
  constructor: (@entitySchema, @name, @options) ->
    @field = "_#{@name}"

    @itemType = TypeTraits.resolve(@options.type)  # works even if options.type is not specified

    @isReactive = @options.reactive ? yes

    if @options.compute
      if @options.compute.length is 0
        @computeTaskDef = new R.TaskDef(@universe, "compute #{@name}", R.TaskDef.AUTOREPEAT, @_recomputeValueSync.bind(@))
      else if @options.compute.length is 1
        @computeTaskDef = new R.TaskDef(@universe, "compute #{@name}", R.TaskDef.AUTOREPEAT, @_recomputeValueAsync.bind(@))
      else
        throw new Error "Compute function for #{@entitySchema}.#{@name} has an invalid signature"

  # For debugging only.
  toString: ->
    "RAttributeSchema(#{@name}, #{JSON.stringify(@options)})"

  Object.defineProperty @::, 'universe', get: ->
    @entitySchema.universe

  initialize: (entity, attributes) ->
    entity[@field] = @_createInitialValue(entity, attributes)

    if @computeTaskDef
      new R.Task(entity, @computeTaskDef)

  freeze: ->
    return if @_frozen
    @_frozen = yes

    @itemType = @itemType.resolve(@universe, "#{@entitySchema}.#{@name}:type")

    if @options.collection
      @collectionClass = @_resolveCollectionClass(@options.collection)
      if !@options.type
        throw new Error "#{@entitySchema}.#{@name}: 'type' key is mandatory for collections"
      unless @itemType.isEntityTypeDescriptor
        throw new Error "#{@entitySchema}.#{@name}: non-entity collections are not implemented yet"

  implement: (prototype) ->
    universe = @universe
    name     = @name
    field    = @field
    type     = @itemType

    unless @isReactive
      if @options.getter or @options.setter
        descriptor =
          enumerable: yes
          configurable: yes
        descriptor.get = @options.getter  if @options.getter
        descriptor.set = @options.setter  if @options.setter
      Object.defineProperty prototype, @name, descriptor
      return

    if @options.getter or @options.setter
      throw new Error "#{this}: Getter/setter is currently only supported for non-reactive attributes"

    if @collectionClass
      descriptor =
        enumerable: yes
        configurable: yes
        get: ->
          return this[field]
        set: ->
          throw new Error "Cannot set collection property #{name}"
    else
      descriptor =
        enumerable: yes
        configurable: yes
        get: ->
          universe.reading(this, name)
          return this[field]
        set: (value) ->
          value = type.coerce(value)
          if this[field] != value
            this[field] = value
            universe.broadcast(this, name)

    Object.defineProperty prototype, @name, descriptor

  _recomputeValueSync: (entity) ->
    newValue = @options.compute.call(entity)
    @_updateComputedValue(entity, newValue)

  _recomputeValueAsync: (entity, callback) ->
    await @options.compute.call entity, defer(err, newValue)
    return callback(err) if err

    @_updateComputedValue(entity, newValue)
    callback(null)

  _updateComputedValue: (entity, newValue) ->
    oldValue = entity[@field]
    if newValue != oldValue
      if @collectionClass
        oldValue._r_updateCollection(newValue)
      else
        entity[@field] = newValue
        @universe.broadcast(entity, @name)

  _resolveCollectionClass: (type) ->
    if typeof type is 'string'
      switch type
        when 'list' then RListCollection
        else throw new Error "Unknown collection type '#{type}'"
    else if typeof type is 'function'
      type
    else
      throw new Error "Invalid type of 'collection' option: '#{type}'"

  _createInitialValue: (entity, attributes) ->
    if @collectionClass
      value = new @collectionClass(entity, this)
      if attributes.hasOwnProperty(@name)
        value._r_setInitialItems(attributes[@name])
      value

    else
      if attributes.hasOwnProperty(@name)
        @itemType.coerce(attributes[@name])
      else if (typeof @options.default) isnt 'undefined'
        @options.default
      else
        @itemType.defaultValue()


class REntity extends EventEmitter
  # For duck type checks.
  isReactiveEntity: yes

  constructor: (owner, @kind, attributes) ->
    @_r_id = @universe.uniqueId(this.constructor.name)

    # debug "%s created", this

    # TODO: notify these parts when disposing the entity.
    @_parts = {}

    @_r_subscribers = {}

    # Attribute initializers may be creating parts, so this must be done after initializing our fields.
    @schema.initialize(this, attributes)


  # For debugging only
  toString: -> @_r_id

  get: (attr) ->
    if @schema.hasAttribute(attr)
      return this[attr]
    else
      throw new Error "Unknown attribute '#{attr}'"

  set: (attr, value) ->
    if @schema.hasAttribute(attr)
      this[attr] = value
    else
      throw new Error "Unknown attribute '#{attr}'"

  isKindOrSubclass: (kind) ->
    @schema.isKindOrSubclass(kind)

  broadcastChange: (topic) ->
    @universe.broadcast(this, topic)

  _r_addPart: (part) ->
    @_parts[part._r_id] = part

  _r_removePart: (part) ->
    delete @_parts[part._r_id]


# An object which does not have its own identity, instead sharing the identity of its owner.
class RPart extends EventEmitter

  constructor: (@owner) ->
    unless @owner? then throw new Error "RPart owner must be provided"
    unless @owner.isReactiveEntity then throw new Error "RPart owner must be an entity"

    @_r_id = @universe.uniqueId(this.constructor.name, @_r_detail)

    @disposed = no
    @owner._r_addPart(this)

  toString: -> @_r_id

  Object.defineProperty @::, 'universe', get: ->
    @owner.universe

  dispose: ->
    return if @disposed
    @disposed = yes
    @_disposed()

  _disposed: ->
    @owner._r_removePart(this)
    @owner = null


class RTaskInvocation
  constructor: (@task) ->
    @_r_id = @universe.uniqueId(this.constructor.name, @task.taskDef.name)

    @complete = no
    @error    = null
    @result   = undefined

    # node domain for all callbacks executed on behalf of this invocation
    @domain = Domain.create()
    @domain._r_task = @task
    @domain.on 'error', @handleError.bind(@)

    # callbacks to be notified when the invocation is complete
    @completionCallbacks = []

    # callbacks to be notified when the invocation is finalized
    @finalizationCallbacks = []

    @childCount = 0
    @children = {}

    @_dependenciesById = {}
    @_topicsByDepId = {}


  Object.defineProperty @::, 'universe', get: ->
    @task.universe


  handleError: (error) ->
    debug "domain.error: #{error}"
    @universe.callbackDomain.run =>
      @markComplete error, undefined


  markComplete: (error, result) ->
    if @complete then throw new Error "EINVAL"

    @complete = yes
    @error    = error
    @result   = result

    if @error
      debug "#{@task} failed: #{@error.stack or @error.message or @error}"
    else
      debug "#{@task} completed successfully"

    @domain.dispose()

    @task._r_invocationCompleted()

    # Emit the task-level event before calling invocation-level handlers to make testing easier.
    @task.emit 'completed', this

    completionCallbackInvoked = (@completionCallbacks.length > 0)
    for callback in @completionCallbacks
      try
        callback(@error, @result)
      catch err
        # In most cases, this error would be caught by the parent domain.
        console.error("Error executing task completion callback: %s", err.stack or err.message or err)
        # questionable approach, but works well in async Mocha tests
        process.nextTick -> throw err
    @completionCallbacks = null

    @_checkFinalized()

    # completion handlers are expected to act on the error, but if there are none, crash the app
    if error and !completionCallbackInvoked
      throw error


  waitCompleted: (callback) ->
    if @complete
      throw new Error "Cannot invoke waitCompleted on completed invocations"
    @completionCallbacks.push(callback)
    return this  # for chaining

  waitFinalized: (callback) ->
    if @_isFinalized()
      throw new Error "Cannot invoke waitFinalized on finalized invocations"
    @finalizationCallbacks.push(callback)
    return this  # for chaining


  addChildInvocation: (childInvocation) ->
    invocationId = childInvocation._r_id
    unless @children.hasOwnProperty(invocationId)
      ++@childCount
      @children[childInvocation._r_id] = childInvocation
      childInvocation.waitFinalized =>
        --@childCount
        delete @children[childInvocation._r_id]
        @_checkFinalized()


  _isFinalized: ->
    return @complete and (@childCount == 0)

  _checkFinalized: ->
    return unless @_isFinalized()

    # debug "#{@task} finalized"

    # Emit the task-level event before calling invocation-level handlers to make testing easier.
    @task.emit 'finalized', this

    for callback in @finalizationCallbacks
      try
        callback(@error, @result)
      catch err
        # in most cases, this error would be caught by the parent domain
        console.error("Error executing task finalization callback: %s", err.stack or err.message or err)
        # questionable approach, but works well in async Mocha tests
        process.nextTick -> throw err
    @finalizationCallbacks = null

  _r_addDependency: (entity, topic) ->
    entityId = entity._r_id

    unless @_dependenciesById.hasOwnProperty(entityId)
      @_dependenciesById[entityId] = entity
      @_topicsByDepId[entityId] = {}

    @_topicsByDepId[entityId][topic] = yes
    undefined


R.TaskDef =
class RTaskDef
  @ONESHOT    = ONESHOT    = 'oneshot'
  @MULTISHOT  = MULTISHOT  = 'multishot'
  @AUTOREPEAT = AUTOREPEAT = 'autorepeat'

  constructor: (@universe, @name, @type, @func, options={}) ->
    unless @type in [ONESHOT, MULTISHOT, AUTOREPEAT]
      throw new Error "RTaskDef: invalid type '#{@type}'"

    @_r_id = @universe.uniqueId(this.constructor.name, @name)
    @async = @func.length is 2

    @multiuse = (@type is MULTISHOT) or (@type is AUTOREPEAT)
    @reactive = (@type is AUTOREPEAT)
    @autoschedule = options.autoschedule ? @reactive
    @autodispose  = options.autodispose ? no


R.Task =
class RTask extends RPart

  constructor: (owner, @taskDef) ->
    @_r_detail = @taskDef.name
    super(owner)

    @scheduledInvocation = null
    @runningInvocation   = null
    @completedInvocation = null

    if @taskDef.autoschedule
      @schedule()


  _disposed: ->
    if @taskDef.autoschedule and @completedInvocation
      oldDependencies = @completedInvocation?._dependenciesById or {}
      for own entityId, entity of oldDependencies
        @universe.subscribe(this, entity, null)

    super


  Object.defineProperty @::, 'lastResult', get: ->
    @completedInvocation?.result

  Object.defineProperty @::, 'lastError', get: ->
    @completedInvocation?.error


  schedule: ->
    if !@taskDef.multiuse and (@runningInvocation or @completedInvocation)
      throw new Error "Cannot reschedule a non-multiuse task"

    # debug "%s scheduled", this

    unless @scheduledInvocation
      @scheduledInvocation = new RTaskInvocation(this)
      @universe.enqueue(@taskDef, @run.bind(@))

    if task = @universe.currentTask
      task._r_addChild(@scheduledInvocation)

    return @scheduledInvocation


  run: ->
    @runningInvocation   = @scheduledInvocation
    @scheduledInvocation = null

    if @taskDef.async
      @_runAsync()
    else
      @_runSync()

  _r_invocationCompleted: ->
    prevInvocation = @completedInvocation
    @completedInvocation = @runningInvocation

    # Subscribe before sending events to avoid missing changes,
    # and also so that subscriptions are all set up by the time finalize callbacks are invoked.
    if @taskDef.reactive
      oldDependencies = prevInvocation?._dependenciesById or {}
      newDependencies = @completedInvocation._dependenciesById
      newTopics = @completedInvocation._topicsByDepId

      for own entityId, entity of oldDependencies when !newDependencies.hasOwnProperty(entityId)
        @universe.subscribe(this, entity, null)
      for own entityId, entity of newDependencies
        @universe.subscribe(this, entity, @completedInvocation._topicsByDepId[entityId])

    if @taskDef.autodispose
      @dispose()

  _runSync: ->
    # debug "%s running", this

    result = @runningInvocation.domain.run(@taskDef.func.bind(@owner, @owner))
    @runningInvocation.markComplete null, result

  _runAsync: ->
    # debug "%s running (async)", this
    await @runningInvocation.domain.run(@taskDef.func.bind(@owner, @owner, defer(err, result)))
    @runningInvocation.markComplete err, result


  _r_addChild: (childInvocation) ->
    unless @runningInvocation
      throw new Error "Internal error: runningInvocation is null in _r_addChild"
    @runningInvocation.addChildInvocation(childInvocation)

  _r_reading: (entity, topic) ->
    if @taskDef.reactive
      # debug "%s depends on %s.%s", this, entity._r_id, topic
      @runningInvocation._r_addDependency(entity, topic)

  _r_changed: (entity, topic) ->
    if @taskDef.reactive
      if topic of @completedInvocation?._topicsByDepId[entity._r_id]
        # debug "#{this}: reschedule because #{entity._r_id}.#{topic} has changed"
        @schedule()


R.Collection =
class RCollection extends RPart

  constructor: (owner, @attrSchema) ->
    super(owner)
    @_initialize()
    @_queries = {}

  _initialize: ->

  at: (index) ->
    @findOne($at: index).get()

  _r_addQuery: (query) ->
    @_queries[query._r_id] = query

  _r_removeQuery: (query) ->
    delete @_queries[query._r_id]


R.ListCollection =
class RListCollection extends RCollection

  _initialize: ->
    super
    @_items = []

  push: (item) ->
    @_items.push(item)

  Object.defineProperty @::, 'all', get: ->
    new RQuery(this, RYesCondition.instance).all

  find: (criteria) ->
    new RQuery(this, RCondition.parse(criteria))

  findOne: (criteria) ->
    criteria = _.extend({ $limit: 1 }, criteria)
    new RSingleItemQuery(@find(criteria))

  _r_setInitialItems: (items) ->
    for item in items
      @_items.push(item)

  _r_all_items: ->
    @_items

  _r_at: (index) ->
    return @_items[index]

  _r_updateCollection: (items) ->
    # debug "#{this} _r_updateCollection: %j", items
    items = items.map(@_mapItem.bind(@))
    @_items.splice(0, @_items.length)
    @_items.push.apply(@_items, items)

  _mapItem: (item) ->
    itemEntitySchema = @attrSchema.itemType
    if not item?
      throw new Error "Null items are not allowed in collections."
    else if typeof(item) is 'object'
      if item.isReactiveEntity and item.isKindOrSubclass(itemEntitySchema.kind)
        item
      else if item.constructor is Object
        itemEntitySchema.create(this, item)
      else
        throw new Error "Invalid item"
    else
      throw new Error "Invalid item type #{typeof item}"


class RSingleItemQuery

  constructor: (@query) ->

  Object.defineProperty @::, 'universe', get: ->
    @query.universe

  # Returns a single result, or `null` if no results are available.
  # Throws an error if more than one result is available.
  get: ->
    items = @query.all
    switch items.length
      when 0
        null
      when 1
        items[0]
      else
        throw new Error "More than 1 result"


class RQuery

  constructor: (@collection, @condition) ->
    @_r_id = @universe.uniqueId(this.constructor.name, @condition.toString())
    @_r_subscribers = {}

  toString: ->
    "RQuery< #{@collection} WHERE #{@condition} >"

  Object.defineProperty @::, 'universe', get: ->
    @collection.universe

  Object.defineProperty @::, 'all', get: ->
    @universe.reading(this, 'all')
    @condition.obtain(@collection)

  _r_subscription_started: ->
    # debug "RQuery _r_subscription_started: #{this}"
    @collection._r_addQuery(this)

  _r_subscription_ended: ->
    # debug "RQuery _r_subscription_ended: #{this}"
    @collection._r_removeQuery(this)


class RCondition
  @parse: (criteria) ->
    conditions = []

    if criteria.$at?
      conditions.push new RIndexMatcher(criteria.$at)

    if criteria.$limit? and not criteria.$at?
      condition.push new RLimitCondition(criteria.$limit)

    for k, v of criteria when !k.match /^\$/
      conditions.push new RAttributeEqualityMatcher(k, v)

    switch conditions.length
      when 0 then RYesCondition.instance
      when 1 then conditions[0]
      else        new RAndCondition(conditions)

  canObtainEfficiently: no

  obtain: (collection) -> @filter(collection._r_all_items())

  filter: (list) -> _.filter(list, (item) -> @matches(item))

  matches: (item) -> yes


class RYesCondition extends RCondition

  toString: ->
    '(all)'

  filter: (list) -> list

  matches: (item) -> yes

  @instance = new @()


class RAndCondition extends RCondition
  constructor: (@conditions) ->
    @_efficientObtainConditions = _.find @conditions, (condition) -> condition.canObtainEfficiently
    @canObtainEfficiently = (@_efficientObtainConditions.length > 0)

  toString: ->
    "(and " + @conditions.join(" ") + ")"

  obtain: (collection) ->
    if @canObtainEfficiently
      @filter(_.intersection.call(_, _.map @_efficientObtainConditions, (condition) -> condition.obtain(collection)))
    else
      super

  filter: (list) ->
    for condition in @conditions
      list = condition.filter(list)
    return list


class RIndexCondition extends RCondition
  constructor: (@index) ->

  toString: ->
    "($at #{@index})"

  canObtainEfficiently: yes

  obtain: (collection) ->
    if (result = collection._r_at(@index))?
      [result]
    else
      []


class RLimitCondition extends RCondition
  constructor: (@limit) ->

  toString: ->
    "($limit #{@limit})"

  filter: (list) ->
    if list.length > @limit
      list.slice(0, @limit)
    else
      list


class RAttributeEqualityCondition extends RCondition
  constructor: (@attrName, @value) ->

  toString: ->
    "(.#{@attrName} == #{@value})"

  matches: (item) ->
    item[@attrName] == @value


class RDummyEntity

class RDuckType
  isTypeDescriptor: yes
  isDuckTypeDescriptor: yes

  constructor: (@name, @requirements) ->

  toString: ->
    "#{@name}-Quack"

  coerce: (value) ->
    if value?
      unless typeof value is 'object'
        throw new Error "Invalid #{typeof value} value, expected a #{@name}-like object"

      missing = null
      for k, v of @requirements
        unless value[k] is v
          missing or= {}
          missing[k] = v

      if missing
        throw new Error "Invalid #{value.constructor.name} value, expected a #{@name}-like object, missing the following keys: #{JSON.stringify missing}"
    value

  defaultValue: ->
    throw new Error "Type #{this} does not have a default value"
