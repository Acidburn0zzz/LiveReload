class OrType
  isTypeDescriptor: yes

  constructor: (@types) ->

  toString: ->
    "[" + @types.map((t) -> t.toString()).join(", ") + "]"

  defaultValue: ->
    @types[0].defaultValue()

  coerce: (value) ->
    err = null
    for type in @types
      try
        return type.coerce(value)
      catch e
        err = e

    throw err

  resolve: (resolver, context) ->
    new OrType(@types.map((t) -> t.resolve(resolver, context)))


class ArrayType
  isTypeDescriptor: yes

  constructor: (@elemType) ->

  toString: ->
    "{ array: #{@elemType} }"

  defaultValue: -> []

  coerce: (value) ->
    unless Array.isArray(value)
      throw new Error("Value is not an array: " + JSON.stringify(value))
    if @elemType is StdTypes.any
      value.slice(0)
    else
      (@elemType.coerce(elem) for elem in value)

  resolve: (resolver, context) ->
    new ArrayType(@elemType.resolve(resolver, context))


class ObjectType
  isTypeDescriptor: yes

  constructor: (@class) ->
    if !@class.name then throw new Error "Only classes with a .name can be used for type checking"

  toString: ->
    "{ object: #{@class.name} }"

  coerce: (value) ->
    unless value?
      throw new Error "Invalid null value, expected #{@class.name}"
    unless typeof value is 'object'
      throw new Error "Invalid #{typeof value} value, expected #{@class.name}"
    unless value instanceof @class
      throw new Error "Invalid #{value.constructor.name or 'object'} value, expected #{@class.name}"
    value

  defaultValue: ->
    throw new Error "Type #{this} does not have a default value"

  resolve: (resolver, context) -> this


class UnresolvedClassReferenceType
  isTypeDescriptor: yes

  constructor: (@name) ->

  toString: ->
    @name

  resolve: (resolver, context) ->
    resolver.resolveClassReference(@name, context)

  coerce: (value) ->
    throw new Error "Trying to use UnresolvedClassReferenceType(#{this})"

  defaultValue: ->
    throw new Error "Trying to use UnresolvedClassReferenceType(#{this})"


StdTypes =
  any:
    isTypeDescriptor: yes
    coerce: (value) ->
      value
    toString: ->
      'any'
    defaultValue: -> undefined
    resolve: (resolver, context) -> this

  string:
    isTypeDescriptor: yes
    coerce: (value) ->
      if value?
        "#{value}"
      else
        null
    toString: ->
      'string'
    defaultValue: -> ''
    resolve: (resolver, context) -> this

  int:
    isTypeDescriptor: yes
    coerce: (value) ->
      switch typeof value
        when 'number', 'string' then ~~value
        else throw new Error "Invalid type #{typeof value}, expected an integer"
    toString: ->
      'int'
    defaultValue: -> 0
    resolve: (resolver, context) -> this

  number:
    isTypeDescriptor: yes
    coerce: (value) ->
      +value
    toString: ->
      'number'
    defaultValue: -> 0
    resolve: (resolver, context) -> this

  boolean:
    isTypeDescriptor: yes
    coerce: (value) ->
      !!value
    toString: ->
      'boolean'
    defaultValue: -> no
    resolve: (resolver, context) -> this

  null:
    isTypeDescriptor: yes
    coerce: (value) ->
      if value?
        throw new Error "Invalid null value"
      else
        null
    toString: ->
      'null'
    defaultValue: -> null
    resolve: (resolver, context) -> this

StdTypes.array = new ArrayType(StdTypes.any)


exports.resolve = resolve = (type, resolver) ->
  if resolver
    result = resolve(type)
    while result.resolve
      result = result.resolve(resolver)
    return result

  if typeof type is 'undefined'
    StdTypes.any
  else if type is null
    StdTypes.null
  else if type.isTypeDescriptor
    type
  else
    switch typeof type
      when 'string'
        if type.match(/\?$/)
          return new OrType([StdTypes.null, resolve(type.substr(0, type.length - 1), resolver)])
        if type.substr(0, 1) == type.substr(0, 1).toUpperCase()
          new UnresolvedClassReferenceType(type)
        else
          StdTypes[type] or throw new Error "Unknown type name #{type}"
      when 'object'
        if type.constructor is Object
          keys = Object.keys(type)
          if (keys.length is 1) and (keys[0] is 'array')
            new ArrayType(resolve(type.array))
          else if (keys.length is 1) and (keys[0] is 'object')
            new ObjectType(type.object)
          else
            throw new Error "Unsupported type declaration #{type}"
        else if Array.isArray(type)
          new OrType(type.map((t) -> resolve(t, resolver)))
        else
          throw new Error "Unsupported type declaration #{type}"
      when 'function'
        if type is String
          StdTypes.string
        else if type is Array
          StdTypes.array
        else if type is Boolean
          StdTypes.boolean
        else if type is Number
          StdTypes.number
        else if type is Object
          StdTypes.any
        else
          new ObjectType(type)


exports.coerce = (value, type) ->
  resolve(type).coerce(value)
