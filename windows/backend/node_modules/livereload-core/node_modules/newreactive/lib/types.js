// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var ArrayType, ObjectType, OrType, StdTypes, UnresolvedClassReferenceType, resolve;

  OrType = (function() {
    OrType.prototype.isTypeDescriptor = true;

    function OrType(types) {
      this.types = types;
    }

    OrType.prototype.toString = function() {
      return "[" + this.types.map(function(t) {
        return t.toString();
      }).join(", ") + "]";
    };

    OrType.prototype.defaultValue = function() {
      return this.types[0].defaultValue();
    };

    OrType.prototype.coerce = function(value) {
      var e, err, type, _i, _len, _ref;
      err = null;
      _ref = this.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        try {
          return type.coerce(value);
        } catch (_error) {
          e = _error;
          err = e;
        }
      }
      throw err;
    };

    OrType.prototype.resolve = function(resolver, context) {
      return new OrType(this.types.map(function(t) {
        return t.resolve(resolver, context);
      }));
    };

    return OrType;

  })();

  ArrayType = (function() {
    ArrayType.prototype.isTypeDescriptor = true;

    function ArrayType(elemType) {
      this.elemType = elemType;
    }

    ArrayType.prototype.toString = function() {
      return "{ array: " + this.elemType + " }";
    };

    ArrayType.prototype.defaultValue = function() {
      return [];
    };

    ArrayType.prototype.coerce = function(value) {
      var elem, _i, _len, _results;
      if (!Array.isArray(value)) {
        throw new Error("Value is not an array: " + JSON.stringify(value));
      }
      if (this.elemType === StdTypes.any) {
        return value.slice(0);
      } else {
        _results = [];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          elem = value[_i];
          _results.push(this.elemType.coerce(elem));
        }
        return _results;
      }
    };

    ArrayType.prototype.resolve = function(resolver, context) {
      return new ArrayType(this.elemType.resolve(resolver, context));
    };

    return ArrayType;

  })();

  ObjectType = (function() {
    ObjectType.prototype.isTypeDescriptor = true;

    function ObjectType(_class) {
      this["class"] = _class;
      if (!this["class"].name) {
        throw new Error("Only classes with a .name can be used for type checking");
      }
    }

    ObjectType.prototype.toString = function() {
      return "{ object: " + this["class"].name + " }";
    };

    ObjectType.prototype.coerce = function(value) {
      if (value == null) {
        throw new Error("Invalid null value, expected " + this["class"].name);
      }
      if (typeof value !== 'object') {
        throw new Error("Invalid " + (typeof value) + " value, expected " + this["class"].name);
      }
      if (!(value instanceof this["class"])) {
        throw new Error("Invalid " + (value.constructor.name || 'object') + " value, expected " + this["class"].name);
      }
      return value;
    };

    ObjectType.prototype.defaultValue = function() {
      throw new Error("Type " + this + " does not have a default value");
    };

    ObjectType.prototype.resolve = function(resolver, context) {
      return this;
    };

    return ObjectType;

  })();

  UnresolvedClassReferenceType = (function() {
    UnresolvedClassReferenceType.prototype.isTypeDescriptor = true;

    function UnresolvedClassReferenceType(name) {
      this.name = name;
    }

    UnresolvedClassReferenceType.prototype.toString = function() {
      return this.name;
    };

    UnresolvedClassReferenceType.prototype.resolve = function(resolver, context) {
      return resolver.resolveClassReference(this.name, context);
    };

    UnresolvedClassReferenceType.prototype.coerce = function(value) {
      throw new Error("Trying to use UnresolvedClassReferenceType(" + this + ")");
    };

    UnresolvedClassReferenceType.prototype.defaultValue = function() {
      throw new Error("Trying to use UnresolvedClassReferenceType(" + this + ")");
    };

    return UnresolvedClassReferenceType;

  })();

  StdTypes = {
    any: {
      isTypeDescriptor: true,
      coerce: function(value) {
        return value;
      },
      toString: function() {
        return 'any';
      },
      defaultValue: function() {
        return void 0;
      },
      resolve: function(resolver, context) {
        return this;
      }
    },
    string: {
      isTypeDescriptor: true,
      coerce: function(value) {
        if (value != null) {
          return "" + value;
        } else {
          return null;
        }
      },
      toString: function() {
        return 'string';
      },
      defaultValue: function() {
        return '';
      },
      resolve: function(resolver, context) {
        return this;
      }
    },
    int: {
      isTypeDescriptor: true,
      coerce: function(value) {
        switch (typeof value) {
          case 'number':
          case 'string':
            return ~~value;
          default:
            throw new Error("Invalid type " + (typeof value) + ", expected an integer");
        }
      },
      toString: function() {
        return 'int';
      },
      defaultValue: function() {
        return 0;
      },
      resolve: function(resolver, context) {
        return this;
      }
    },
    number: {
      isTypeDescriptor: true,
      coerce: function(value) {
        return +value;
      },
      toString: function() {
        return 'number';
      },
      defaultValue: function() {
        return 0;
      },
      resolve: function(resolver, context) {
        return this;
      }
    },
    boolean: {
      isTypeDescriptor: true,
      coerce: function(value) {
        return !!value;
      },
      toString: function() {
        return 'boolean';
      },
      defaultValue: function() {
        return false;
      },
      resolve: function(resolver, context) {
        return this;
      }
    },
    "null": {
      isTypeDescriptor: true,
      coerce: function(value) {
        if (value != null) {
          throw new Error("Invalid null value");
        } else {
          return null;
        }
      },
      toString: function() {
        return 'null';
      },
      defaultValue: function() {
        return null;
      },
      resolve: function(resolver, context) {
        return this;
      }
    }
  };

  StdTypes.array = new ArrayType(StdTypes.any);

  exports.resolve = resolve = function(type, resolver) {
    var keys, result;
    if (resolver) {
      result = resolve(type);
      while (result.resolve) {
        result = result.resolve(resolver);
      }
      return result;
    }
    if (typeof type === 'undefined') {
      return StdTypes.any;
    } else if (type === null) {
      return StdTypes["null"];
    } else if (type.isTypeDescriptor) {
      return type;
    } else {
      switch (typeof type) {
        case 'string':
          if (type.match(/\?$/)) {
            return new OrType([StdTypes["null"], resolve(type.substr(0, type.length - 1), resolver)]);
          }
          if (type.substr(0, 1) === type.substr(0, 1).toUpperCase()) {
            return new UnresolvedClassReferenceType(type);
          } else {
            return StdTypes[type] || (function() {
              throw new Error("Unknown type name " + type);
            })();
          }
          break;
        case 'object':
          if (type.constructor === Object) {
            keys = Object.keys(type);
            if ((keys.length === 1) && (keys[0] === 'array')) {
              return new ArrayType(resolve(type.array));
            } else if ((keys.length === 1) && (keys[0] === 'object')) {
              return new ObjectType(type.object);
            } else {
              throw new Error("Unsupported type declaration " + type);
            }
          } else if (Array.isArray(type)) {
            return new OrType(type.map(function(t) {
              return resolve(t, resolver);
            }));
          } else {
            throw new Error("Unsupported type declaration " + type);
          }
          break;
        case 'function':
          if (type === String) {
            return StdTypes.string;
          } else if (type === Array) {
            return StdTypes.array;
          } else if (type === Boolean) {
            return StdTypes.boolean;
          } else if (type === Number) {
            return StdTypes.number;
          } else if (type === Object) {
            return StdTypes.any;
          } else {
            return new ObjectType(type);
          }
      }
    }
  };

  exports.coerce = function(value, type) {
    return resolve(type).coerce(value);
  };

}).call(this);
