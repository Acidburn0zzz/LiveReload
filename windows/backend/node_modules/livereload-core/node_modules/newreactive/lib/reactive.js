// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var $typeOf, Domain, EventEmitter, MAGIC_METHODS, R, RAndCondition, RAttributeEqualityCondition, RAttributeSchema, RCollection, RCondition, RDuckType, RDummyEntity, REntity, REntitySchema, RIndexCondition, RLimitCondition, RListCollection, RPart, RQuery, RSingleItemQuery, RTask, RTaskDef, RTaskInvocation, RUniverse, RYesCondition, TypeTraits, assertKeys, createNamedSubclass, debug, iced, _, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        ++this.count;
        return (function(_this) {
          return function() {
            var inner_params, _ref;
            inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (defer_params != null) {
              if ((_ref = defer_params.assign_fn) != null) {
                _ref.apply(null, inner_params);
              }
            }
            return _this._fulfill();
          };
        })(this);
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  _ = require('underscore');

  debug = require('debug')('reactive');

  EventEmitter = require('events').EventEmitter;

  Domain = require('domain');

  TypeTraits = require('./types');

  module.exports = R = {
    VERSION: '0.0.0'
  };

  MAGIC_METHODS = {
    getter: 'get_%',
    setter: 'set_%',
    compute: 'compute_%',
    initializer: 'initialize_%'
  };

  createNamedSubclass = function(name, superclass) {
    var subclass;
    if (false) {
      subclass = (function(_super) {
        __extends(subclass, _super);

        function subclass() {
          return subclass.__super__.constructor.apply(this, arguments);
        }

        return subclass;

      })(superclass);
      subclass.name = name;
    } else {
      global.REACTIVE_CLASS_CREATION_HACK = superclass;
      subclass = eval("(function(superclass) { return function " + name + "() { superclass.apply(this, arguments); }; })(global.REACTIVE_CLASS_CREATION_HACK);");
      delete global.REACTIVE_CLASS_CREATION_HACK;
      __extends(subclass, superclass);;
    }
    return subclass;
  };

  $typeOf = function(val) {
    var type;
    type = typeof val;
    if (type === 'object') {
      if (val == null) {
        return 'null';
      } else if (Array.isArray(val)) {
        return 'array';
      } else {
        return 'object';
      }
    } else {
      return type;
    }
  };

  assertKeys = function(options, mandatoryKeys, optionalKeys, context) {
    var actualKeys, allowedKeys, extra, missing;
    actualKeys = Object.keys(options);
    allowedKeys = mandatoryKeys.concat(optionalKeys);
    missing = _.difference(mandatoryKeys, actualKeys);
    extra = _.difference(actualKeys, allowedKeys);
    if (missing.length > 0) {
      throw new Error("Missing mandatory key(s) " + (missing.join(', ')) + " in " + context);
    }
    if (extra.length > 0) {
      throw new Error("Unsupported key(s) " + (extra.join(', ')) + " in " + context);
    }
  };

  R.kindFromClass = function(klass) {
    if (!klass.name) {
      throw new Error("R requires entity classes to have a non-empty 'name'");
    }
    return klass.name.replace(/_.*$/, '');
  };

  R.Universe = RUniverse = (function() {
    var _nextUniverseId;

    _nextUniverseId = 1;

    function RUniverse() {
      this.resolveClassReference = __bind(this.resolveClassReference, this);
      this._id = "RUniverse" + (_nextUniverseId++);
      this._nextIdPerClass = {};
      this.kinds = {};
      this.ducks = {};
      this.callbackDomain = Domain.create();
    }

    RUniverse.prototype.toString = function() {
      return this._id;
    };

    RUniverse.prototype.dispose = function() {};

    RUniverse.prototype.uniqueId = function(className, detail) {
      var ordinal, _base;
      if (className == null) {
        className = '';
      }
      detail = detail ? ('_' + detail).replace(/[^0-9a-zA-Z]+/g, '_') : '';
      (_base = this._nextIdPerClass)[className] || (_base[className] = 1);
      ordinal = this._nextIdPerClass[className]++;
      return "" + className + ordinal + detail;
    };

    RUniverse.prototype.define = function() {
      var arg, args, index, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        throw new Error("R.Universe.define requires an argument");
      }
      _results = [];
      for (index = _i = 0, _len = args.length; _i < _len; index = ++_i) {
        arg = args[index];
        _results.push(this._defineMany(arg, "arguments[" + index + "]"));
      }
      return _results;
    };

    RUniverse.prototype._defineMany = function(arg, context) {
      var index, item, type, _i, _len, _results;
      switch (type = $typeOf(arg)) {
        case 'object':
          return this._defineOne(arg, context);
        case 'function':
          return this._defineOne({
            klass: arg
          }, context);
        case 'array':
          _results = [];
          for (index = _i = 0, _len = arg.length; _i < _len; index = ++_i) {
            item = arg[index];
            _results.push(this._defineMany(item, "" + context + "[" + index + "]"));
          }
          return _results;
          break;
        default:
          throw new Error("R.Universe.define: invalid type '" + type + "' for " + context);
      }
    };

    RUniverse.prototype._defineOne = function(options, context) {
      if (options.duck) {
        return this._defineDuck(options, context);
      } else if (options.klass) {
        return this._defineMixin(options, context);
      } else {
        throw new Error("R.Universe.define: invalid option keys " + (JSON.stringify(Object.keys(options))) + " in " + context);
      }
    };

    RUniverse.prototype._defineDuck = function(options, context) {
      assertKeys(options, ['name', 'duck'], [], "R.Universe.define, " + context + ", recognized as duck type definition");
      return this.ducks[options.name] = new RDuckType(options.name, options.duck);
    };

    RUniverse.prototype._defineMixin = function(options, context) {
      var kind, schema;
      assertKeys(options, ['klass'], [], "R.Universe.define, " + context + ", recognized as mixin definition");
      kind = R.kindFromClass(options.klass);
      if (this.kinds.hasOwnProperty(kind)) {
        schema = this.kinds[kind];
      } else {
        schema = this.kinds[kind] = new REntitySchema(this, kind);
      }
      schema.addClass(options.klass);
      return schema;
    };

    RUniverse.prototype.findEntityKind = function(kind) {
      if (this.kinds.hasOwnProperty(kind)) {
        return this.kinds[kind];
      } else {
        return null;
      }
    };

    RUniverse.prototype.resolveEntityKind = function(kind) {
      return this.findEntityKind(kind) || (function() {
        throw new Error("Unknown kind '" + kind + "'");
      })();
    };

    RUniverse.prototype.create = function(kind, attributes) {
      var legacyClass, schema;
      if (attributes == null) {
        attributes = {};
      }
      if (typeof kind === 'function') {
        legacyClass = kind;
        kind = legacyClass.name;
        if (!this.kinds.hasOwnProperty(kind)) {
          this.define(legacyClass);
        }
      }
      schema = this.findEntityKind(kind) || (function() {
        throw new Error("R.create: unknown entity kind '" + kind + "'");
      })();
      return schema.create(this, attributes);
    };

    RUniverse.prototype.reading = function(entity, topic) {
      var task;
      if (!entity._r_id) {
        throw new Error("RUniverse.reading: entity must have _r_id");
      }
      if (task = this.currentTask) {
        return task._r_reading(entity, topic);
      }
    };

    RUniverse.prototype.broadcast = function(entity, topic) {
      var dependent, dependentId, _ref, _results;
      if (!entity._r_id) {
        throw new Error("RUniverse.broadcast: entity must have _r_id");
      }
      _ref = entity._r_subscribers;
      _results = [];
      for (dependentId in _ref) {
        if (!__hasProp.call(_ref, dependentId)) continue;
        dependent = _ref[dependentId];
        _results.push(dependent._r_changed(entity, topic));
      }
      return _results;
    };

    RUniverse.prototype.subscribe = function(dependent, entity, topicSet) {
      var isEmpty, topicSetKeys, wasEmpty;
      if (!dependent._r_id) {
        throw new new Error("EINVAL: dependent must have _r_id");
      }
      topicSetKeys = (topicSet ? Object.keys(topicSet) : null);
      wasEmpty = Object.keys(entity._r_subscribers).length === 0;
      if (topicSet && Object.keys(topicSet).length > 0) {
        entity._r_subscribers[dependent._r_id] = dependent;
      } else {
        delete entity._r_subscribers[dependent._r_id];
      }
      isEmpty = Object.keys(entity._r_subscribers).length === 0;
      if (wasEmpty !== isEmpty) {
        if (isEmpty) {
          return typeof entity._r_subscription_ended === "function" ? entity._r_subscription_ended() : void 0;
        } else {
          return typeof entity._r_subscription_started === "function" ? entity._r_subscription_started() : void 0;
        }
      }
    };

    Object.defineProperty(RUniverse.prototype, 'currentTask', {
      get: function() {
        var _ref;
        return (_ref = Domain.active) != null ? _ref._r_task : void 0;
      }
    });

    RUniverse.prototype.enqueue = function(taskDef, func) {
      if (typeof func !== 'function') {
        throw new Error("R.Universe.enqueue: func is not a function");
      }
      return this.callbackDomain.run(function() {
        return process.nextTick(func);
      });
    };

    RUniverse.prototype.performAndWait = function(func, done) {
      var name, task, taskDef;
      this.dummyEntity || (this.dummyEntity = this.create(RDummyEntity));
      name = func.name || "Universe.performAndWait";
      taskDef = new R.TaskDef(this, name, R.TaskDef.ONESHOT, (function() {
        return func.call(this);
      }), {
        autodispose: true
      });
      task = new R.Task(this.dummyEntity, taskDef);
      return task.schedule().waitFinalized(done);
    };

    RUniverse.prototype.resolveClassReference = function(name, context) {
      var kind;
      if (this.ducks.hasOwnProperty(name)) {
        return this.ducks[name];
      } else if (kind = this.findEntityKind(name)) {
        return kind;
      } else {
        throw new Error("Unknown type or entity kind name: '" + name + "' in " + context);
      }
    };

    return RUniverse;

  })();

  REntitySchema = (function() {
    REntitySchema.prototype.isTypeDescriptor = true;

    REntitySchema.prototype.isEntityTypeDescriptor = true;

    function REntitySchema(universe, kind) {
      this.universe = universe;
      this.kind = kind;
      this._r_id = this.kind;
      this.klasses = [];
      this.superSchemas = [];
      this._ownAttributeSchemas = {};
      this.automaticBlockTaskDefs = [];
      this._instanceMethods = {};
      this._frozen = false;
      this._hooks = {};
      this._ancestorSchemas = null;
      this._ancestorSchemasByKindName = null;
      this._attributeSchemas = null;
    }

    REntitySchema.prototype.toString = function() {
      return "REntitySchema(" + this.kind + ")";
    };

    REntitySchema.prototype.addClass = function(klass) {
      var key, value, _ref;
      if (this._frozen) {
        throw new Error("" + this + ": cannot add a mixin to a frozen entity");
      }
      if (this.klasses.indexOf(klass) < 0) {
        this.klasses.push(klass);
        if (klass.prototype.__proto__) {
          if (klass.prototype.__proto__.constructor !== Object) {
            throw new Error("Entity inheritance must be specified via $extends, not by actually inheriting a mixin class in " + this + ", class " + klass.name);
          }
        }
        _ref = klass.prototype;
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          value = _ref[key];
          if (key !== 'schema') {
            this._instanceMethods[key] = value;
          }
        }
        this._handleEntityWideMagicMethods(klass.prototype);
        return this._addSchema(klass.schema || klass.prototype.schema || {}, klass.prototype, ["mixin class " + klass.name]);
      }
    };

    REntitySchema.prototype.create = function(owner, attributes) {
      if (!this._frozen) {
        this._freeze();
      }
      return new this.EntityClass(owner, this.kind, attributes);
    };

    REntitySchema.prototype.initialize = function(entity, attributes) {
      var attr, attrName, entitySchema, _i, _len, _ref, _ref1, _results;
      if (!this._frozen) {
        this._freeze();
      }
      _ref = this._attributeSchemas;
      for (attrName in _ref) {
        if (!__hasProp.call(_ref, attrName)) continue;
        attr = _ref[attrName];
        attr.initialize(entity, attributes);
      }
      this.hook('initialize', entity, attributes);
      _ref1 = this._ancestorSchemas;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        entitySchema = _ref1[_i];
        _results.push(entitySchema._initializeAutomaticTasks(entity));
      }
      return _results;
    };

    REntitySchema.prototype._initializeAutomaticTasks = function(entity) {
      var taskDef, _i, _len, _ref, _results;
      _ref = this.automaticBlockTaskDefs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        taskDef = _ref[_i];
        _results.push(new R.Task(entity, taskDef));
      }
      return _results;
    };

    REntitySchema.prototype.hook = function() {
      var args, entity, entitySchema, func, funcs, methodName, mixin, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      methodName = arguments[0], entity = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (!this._hooks.hasOwnProperty(methodName)) {
        funcs = [];
        _ref = this._ancestorSchemas;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          entitySchema = _ref[_i];
          _ref1 = entitySchema.klasses;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            mixin = _ref1[_j];
            if (mixin.prototype.hasOwnProperty(methodName)) {
              funcs.push(mixin.prototype[methodName]);
            }
          }
        }
        this._hooks[methodName] = funcs;
      }
      _ref2 = this._hooks[methodName];
      _results = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        func = _ref2[_k];
        _results.push(func.apply(entity, args));
      }
      return _results;
    };

    REntitySchema.prototype.isKindOrSubclass = function(kind) {
      return this._ancestorSchemasByKindName.hasOwnProperty(kind);
    };

    REntitySchema.prototype.extend = function(kind) {
      var superSchema;
      superSchema = this.universe.resolveEntityKind(kind);
      if (this._frozen) {
        throw "" + this + ": cannot add a superclass to a frozen entity";
      }
      if (!(this.superSchemas.indexOf(superSchema) >= 0)) {
        return this.superSchemas.push(superSchema);
      }
    };

    REntitySchema.prototype._freeze = function() {
      if (this._frozen) {
        return;
      }
      this._frozen = true;
      this._computeAncestryChain();
      this._computeMergedAttributeSet();
      this._freezeAttributes();
      return this._buildModelClass();
    };

    REntitySchema.prototype._computeAncestryChain = function() {
      var schema, _i, _len, _ref, _results;
      this._ancestorSchemas = [];
      this._computeAncestryChain_dfs(this._ancestorSchemas, {});
      this._ancestorSchemasByKindName = {};
      _ref = this._ancestorSchemas;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        schema = _ref[_i];
        _results.push(this._ancestorSchemasByKindName[schema.kind] = schema);
      }
      return _results;
    };

    REntitySchema.prototype._computeAncestryChain_dfs = function(ancestorSchemas, visitedEntitySchemas) {
      var superSchema, _i, _len, _ref;
      visitedEntitySchemas[this._r_id] = true;
      ancestorSchemas.push(this);
      _ref = this.superSchemas;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        superSchema = _ref[_i];
        if (!visitedEntitySchemas[superSchema._r_id]) {
          superSchema._computeAncestryChain_dfs(ancestorSchemas, visitedEntitySchemas);
        }
      }
      return void 0;
    };

    REntitySchema.prototype._computeMergedAttributeSet = function() {
      var attrSchema, k, schema, _i, _len, _ref, _ref1;
      this._attributeSchemas = {};
      _ref = this._ancestorSchemas;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        schema = _ref[_i];
        _ref1 = schema._ownAttributeSchemas;
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          attrSchema = _ref1[k];
          if (!this._attributeSchemas.hasOwnProperty(attrSchema.name)) {
            this._attributeSchemas[attrSchema.name] = attrSchema;
          }
        }
      }
      return void 0;
    };

    REntitySchema.prototype._freezeAttributes = function() {
      var attrSchema, key, _ref;
      _ref = this._attributeSchemas;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        attrSchema = _ref[key];
        attrSchema.freeze();
      }
      return void 0;
    };

    REntitySchema.prototype._buildModelClass = function() {
      var attrSchema, k, key, schema, value, _i, _len, _ref, _ref1, _ref2, _results;
      this.EntityClass = createNamedSubclass(this.kind, REntity);
      this.EntityClass.prototype.schema = this.EntityClass.schema = this;
      this.EntityClass.prototype.universe = this.EntityClass.universe = this.universe;
      _ref = this._ancestorSchemas;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        schema = _ref[_i];
        _ref1 = schema._instanceMethods;
        for (key in _ref1) {
          if (!__hasProp.call(_ref1, key)) continue;
          value = _ref1[key];
          if (!this.EntityClass.prototype.hasOwnProperty(key)) {
            this.EntityClass.prototype[key] = value;
          }
        }
      }
      _ref2 = this._attributeSchemas;
      _results = [];
      for (k in _ref2) {
        if (!__hasProp.call(_ref2, k)) continue;
        attrSchema = _ref2[k];
        _results.push(attrSchema.implement(this.EntityClass.prototype));
      }
      return _results;
    };

    REntitySchema.prototype.hasAttribute = function(name) {
      if (!this._frozen) {
        this._freeze();
      }
      return this._attributeSchemas.hasOwnProperty(name);
    };

    REntitySchema.prototype._handleEntityWideMagicMethods = function(prototype) {
      var key, m, value, _results;
      _results = [];
      for (key in prototype) {
        if (!__hasProp.call(prototype, key)) continue;
        value = prototype[key];
        if (m = key.match(/^automatically_(.*)$/)) {
          _results.push(this.automaticBlockTaskDefs.push(new R.TaskDef(this.universe, m[1], R.TaskDef.AUTOREPEAT, value)));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    REntitySchema.prototype._addSchema = function(schema, prototype, errorContext) {
      var key, value;
      for (key in schema) {
        if (!__hasProp.call(schema, key)) continue;
        value = schema[key];
        if (key[0] === '$') {
          this._handleSpecialSchemaKey(key, value, errorContext);
        } else {
          this._defineAttribute(key, value, prototype);
        }
      }
      return void 0;
    };

    REntitySchema.prototype._defineAttribute = function(attrName, attrOptions, prototype) {
      var methodName, optionsKey;
      for (optionsKey in MAGIC_METHODS) {
        if (!__hasProp.call(MAGIC_METHODS, optionsKey)) continue;
        methodName = MAGIC_METHODS[optionsKey];
        this._convertMethodIntoOption(prototype, attrOptions, methodName.replace('%', attrName), optionsKey);
      }
      return this._addAttribute(new RAttributeSchema(this, attrName, attrOptions));
    };

    REntitySchema.prototype._convertMethodIntoOption = function(prototype, options, methodName, optionsKey) {
      if (prototype.hasOwnProperty(methodName)) {
        options[optionsKey] = prototype[methodName];
        return delete prototype[methodName];
      }
    };

    REntitySchema.prototype._handleSpecialSchemaKey = function(key, value, errorContext) {
      errorContext = errorContext.concat(["schema." + key]);
      switch (key) {
        case '$extends':
          return this._handleExtendsKey(value, errorContext);
        case '$includes':
          return this._handleIncludesKey(value, errorContext);
        default:
          throw new Error("" + this + ": unsupported special key " + key);
      }
    };

    REntitySchema.prototype._handleExtendsKey = function(value, errorContext) {
      var item, _i, _len, _results;
      if (typeof value === 'string') {
        value = [value];
      }
      _results = [];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        item = value[_i];
        if (typeof item !== 'string') {
          throw new Error("Invalid superclass '" + (typeof item) + "', expected a kind name (string) in " + (errorContext.join(', ')));
        }
        _results.push(this.extend(item));
      }
      return _results;
    };

    REntitySchema.prototype._handleIncludesKey = function(value, errorContext) {
      var item, _i, _len, _results;
      if (typeof value === 'function') {
        value = [value];
      }
      _results = [];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        item = value[_i];
        if (typeof item !== 'function') {
          throw new Error("Invalid mixin '" + (typeof item) + "', expected a mixin class (a function) in " + (errorContext.join(', ')));
        }
        _results.push(this.addClass(item));
      }
      return _results;
    };

    REntitySchema.prototype._addAttribute = function(attrSchema) {
      return this._ownAttributeSchemas[attrSchema.name] = attrSchema;
    };

    REntitySchema.prototype.coerce = function(value) {
      if (value != null) {
        if (typeof value !== 'object') {
          throw new Error("Invalid " + (typeof value) + " value, expected " + this.kind + " entity");
        }
        if (!value.isReactiveEntity) {
          throw new Error("Invalid " + value.constructor.name + " value, expected " + this.kind + " entity");
        }
        if (!value.isKindOrSubclass(this.kind)) {
          throw new Error("Invalid " + value.kind + " entity, expected " + this["class"].name);
        }
      }
      return value;
    };

    REntitySchema.prototype.defaultValue = function() {
      throw new Error("Type " + this + " does not have a default value");
    };

    return REntitySchema;

  })();

  RAttributeSchema = (function() {
    function RAttributeSchema(entitySchema, name, options) {
      var _ref;
      this.entitySchema = entitySchema;
      this.name = name;
      this.options = options;
      this.field = "_" + this.name;
      this.itemType = TypeTraits.resolve(this.options.type);
      this.isReactive = (_ref = this.options.reactive) != null ? _ref : true;
      if (this.options.compute) {
        if (this.options.compute.length === 0) {
          this.computeTaskDef = new R.TaskDef(this.universe, "compute " + this.name, R.TaskDef.AUTOREPEAT, this._recomputeValueSync.bind(this));
        } else if (this.options.compute.length === 1) {
          this.computeTaskDef = new R.TaskDef(this.universe, "compute " + this.name, R.TaskDef.AUTOREPEAT, this._recomputeValueAsync.bind(this));
        } else {
          throw new Error("Compute function for " + this.entitySchema + "." + this.name + " has an invalid signature");
        }
      }
    }

    RAttributeSchema.prototype.toString = function() {
      return "RAttributeSchema(" + this.name + ", " + (JSON.stringify(this.options)) + ")";
    };

    Object.defineProperty(RAttributeSchema.prototype, 'universe', {
      get: function() {
        return this.entitySchema.universe;
      }
    });

    RAttributeSchema.prototype.initialize = function(entity, attributes) {
      entity[this.field] = this._createInitialValue(entity, attributes);
      if (this.computeTaskDef) {
        return new R.Task(entity, this.computeTaskDef);
      }
    };

    RAttributeSchema.prototype.freeze = function() {
      if (this._frozen) {
        return;
      }
      this._frozen = true;
      this.itemType = this.itemType.resolve(this.universe, "" + this.entitySchema + "." + this.name + ":type");
      if (this.options.collection) {
        this.collectionClass = this._resolveCollectionClass(this.options.collection);
        if (!this.options.type) {
          throw new Error("" + this.entitySchema + "." + this.name + ": 'type' key is mandatory for collections");
        }
        if (!this.itemType.isEntityTypeDescriptor) {
          throw new Error("" + this.entitySchema + "." + this.name + ": non-entity collections are not implemented yet");
        }
      }
    };

    RAttributeSchema.prototype.implement = function(prototype) {
      var descriptor, field, name, type, universe;
      universe = this.universe;
      name = this.name;
      field = this.field;
      type = this.itemType;
      if (!this.isReactive) {
        if (this.options.getter || this.options.setter) {
          descriptor = {
            enumerable: true,
            configurable: true
          };
          if (this.options.getter) {
            descriptor.get = this.options.getter;
          }
          if (this.options.setter) {
            descriptor.set = this.options.setter;
          }
        }
        Object.defineProperty(prototype, this.name, descriptor);
        return;
      }
      if (this.options.getter || this.options.setter) {
        throw new Error("" + this + ": Getter/setter is currently only supported for non-reactive attributes");
      }
      if (this.collectionClass) {
        descriptor = {
          enumerable: true,
          configurable: true,
          get: function() {
            return this[field];
          },
          set: function() {
            throw new Error("Cannot set collection property " + name);
          }
        };
      } else {
        descriptor = {
          enumerable: true,
          configurable: true,
          get: function() {
            universe.reading(this, name);
            return this[field];
          },
          set: function(value) {
            value = type.coerce(value);
            if (this[field] !== value) {
              this[field] = value;
              return universe.broadcast(this, name);
            }
          }
        };
      }
      return Object.defineProperty(prototype, this.name, descriptor);
    };

    RAttributeSchema.prototype._recomputeValueSync = function(entity) {
      var newValue;
      newValue = this.options.compute.call(entity);
      return this._updateComputedValue(entity, newValue);
    };

    RAttributeSchema.prototype._recomputeValueAsync = function(entity, callback) {
      var err, newValue, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "C:\\dev\\LiveReload\\node_modules\\newreactive\\lib\\reactive.iced",
            funcname: "RAttributeSchema._recomputeValueAsync"
          });
          _this.options.compute.call(entity, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return newValue = arguments[1];
              };
            })(),
            lineno: 561
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (err) {
            return callback(err);
          }
          _this._updateComputedValue(entity, newValue);
          return callback(null);
        };
      })(this));
    };

    RAttributeSchema.prototype._updateComputedValue = function(entity, newValue) {
      var oldValue;
      oldValue = entity[this.field];
      if (newValue !== oldValue) {
        if (this.collectionClass) {
          return oldValue._r_updateCollection(newValue);
        } else {
          entity[this.field] = newValue;
          return this.universe.broadcast(entity, this.name);
        }
      }
    };

    RAttributeSchema.prototype._resolveCollectionClass = function(type) {
      if (typeof type === 'string') {
        switch (type) {
          case 'list':
            return RListCollection;
          default:
            throw new Error("Unknown collection type '" + type + "'");
        }
      } else if (typeof type === 'function') {
        return type;
      } else {
        throw new Error("Invalid type of 'collection' option: '" + type + "'");
      }
    };

    RAttributeSchema.prototype._createInitialValue = function(entity, attributes) {
      var value;
      if (this.collectionClass) {
        value = new this.collectionClass(entity, this);
        if (attributes.hasOwnProperty(this.name)) {
          value._r_setInitialItems(attributes[this.name]);
        }
        return value;
      } else {
        if (attributes.hasOwnProperty(this.name)) {
          return this.itemType.coerce(attributes[this.name]);
        } else if ((typeof this.options["default"]) !== 'undefined') {
          return this.options["default"];
        } else {
          return this.itemType.defaultValue();
        }
      }
    };

    return RAttributeSchema;

  })();

  REntity = (function(_super) {
    __extends(REntity, _super);

    REntity.prototype.isReactiveEntity = true;

    function REntity(owner, kind, attributes) {
      this.kind = kind;
      this._r_id = this.universe.uniqueId(this.constructor.name);
      this._parts = {};
      this._r_subscribers = {};
      this.schema.initialize(this, attributes);
    }

    REntity.prototype.toString = function() {
      return this._r_id;
    };

    REntity.prototype.get = function(attr) {
      if (this.schema.hasAttribute(attr)) {
        return this[attr];
      } else {
        throw new Error("Unknown attribute '" + attr + "'");
      }
    };

    REntity.prototype.set = function(attr, value) {
      if (this.schema.hasAttribute(attr)) {
        return this[attr] = value;
      } else {
        throw new Error("Unknown attribute '" + attr + "'");
      }
    };

    REntity.prototype.isKindOrSubclass = function(kind) {
      return this.schema.isKindOrSubclass(kind);
    };

    REntity.prototype.broadcastChange = function(topic) {
      return this.universe.broadcast(this, topic);
    };

    REntity.prototype._r_addPart = function(part) {
      return this._parts[part._r_id] = part;
    };

    REntity.prototype._r_removePart = function(part) {
      return delete this._parts[part._r_id];
    };

    return REntity;

  })(EventEmitter);

  RPart = (function(_super) {
    __extends(RPart, _super);

    function RPart(owner) {
      this.owner = owner;
      if (this.owner == null) {
        throw new Error("RPart owner must be provided");
      }
      if (!this.owner.isReactiveEntity) {
        throw new Error("RPart owner must be an entity");
      }
      this._r_id = this.universe.uniqueId(this.constructor.name, this._r_detail);
      this.disposed = false;
      this.owner._r_addPart(this);
    }

    RPart.prototype.toString = function() {
      return this._r_id;
    };

    Object.defineProperty(RPart.prototype, 'universe', {
      get: function() {
        return this.owner.universe;
      }
    });

    RPart.prototype.dispose = function() {
      if (this.disposed) {
        return;
      }
      this.disposed = true;
      return this._disposed();
    };

    RPart.prototype._disposed = function() {
      this.owner._r_removePart(this);
      return this.owner = null;
    };

    return RPart;

  })(EventEmitter);

  RTaskInvocation = (function() {
    function RTaskInvocation(task) {
      this.task = task;
      this._r_id = this.universe.uniqueId(this.constructor.name, this.task.taskDef.name);
      this.complete = false;
      this.error = null;
      this.result = void 0;
      this.domain = Domain.create();
      this.domain._r_task = this.task;
      this.domain.on('error', this.handleError.bind(this));
      this.completionCallbacks = [];
      this.finalizationCallbacks = [];
      this.childCount = 0;
      this.children = {};
      this._dependenciesById = {};
      this._topicsByDepId = {};
    }

    Object.defineProperty(RTaskInvocation.prototype, 'universe', {
      get: function() {
        return this.task.universe;
      }
    });

    RTaskInvocation.prototype.handleError = function(error) {
      debug("domain.error: " + error);
      return this.universe.callbackDomain.run((function(_this) {
        return function() {
          return _this.markComplete(error, void 0);
        };
      })(this));
    };

    RTaskInvocation.prototype.markComplete = function(error, result) {
      var callback, completionCallbackInvoked, err, _i, _len, _ref;
      if (this.complete) {
        throw new Error("EINVAL");
      }
      this.complete = true;
      this.error = error;
      this.result = result;
      if (this.error) {
        debug("" + this.task + " failed: " + (this.error.stack || this.error.message || this.error));
      } else {
        debug("" + this.task + " completed successfully");
      }
      this.domain.dispose();
      this.task._r_invocationCompleted();
      this.task.emit('completed', this);
      completionCallbackInvoked = this.completionCallbacks.length > 0;
      _ref = this.completionCallbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        try {
          callback(this.error, this.result);
        } catch (_error) {
          err = _error;
          console.error("Error executing task completion callback: %s", err.stack || err.message || err);
          process.nextTick(function() {
            throw err;
          });
        }
      }
      this.completionCallbacks = null;
      this._checkFinalized();
      if (error && !completionCallbackInvoked) {
        throw error;
      }
    };

    RTaskInvocation.prototype.waitCompleted = function(callback) {
      if (this.complete) {
        throw new Error("Cannot invoke waitCompleted on completed invocations");
      }
      this.completionCallbacks.push(callback);
      return this;
    };

    RTaskInvocation.prototype.waitFinalized = function(callback) {
      if (this._isFinalized()) {
        throw new Error("Cannot invoke waitFinalized on finalized invocations");
      }
      this.finalizationCallbacks.push(callback);
      return this;
    };

    RTaskInvocation.prototype.addChildInvocation = function(childInvocation) {
      var invocationId;
      invocationId = childInvocation._r_id;
      if (!this.children.hasOwnProperty(invocationId)) {
        ++this.childCount;
        this.children[childInvocation._r_id] = childInvocation;
        return childInvocation.waitFinalized((function(_this) {
          return function() {
            --_this.childCount;
            delete _this.children[childInvocation._r_id];
            return _this._checkFinalized();
          };
        })(this));
      }
    };

    RTaskInvocation.prototype._isFinalized = function() {
      return this.complete && (this.childCount === 0);
    };

    RTaskInvocation.prototype._checkFinalized = function() {
      var callback, err, _i, _len, _ref;
      if (!this._isFinalized()) {
        return;
      }
      this.task.emit('finalized', this);
      _ref = this.finalizationCallbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        try {
          callback(this.error, this.result);
        } catch (_error) {
          err = _error;
          console.error("Error executing task finalization callback: %s", err.stack || err.message || err);
          process.nextTick(function() {
            throw err;
          });
        }
      }
      return this.finalizationCallbacks = null;
    };

    RTaskInvocation.prototype._r_addDependency = function(entity, topic) {
      var entityId;
      entityId = entity._r_id;
      if (!this._dependenciesById.hasOwnProperty(entityId)) {
        this._dependenciesById[entityId] = entity;
        this._topicsByDepId[entityId] = {};
      }
      this._topicsByDepId[entityId][topic] = true;
      return void 0;
    };

    return RTaskInvocation;

  })();

  R.TaskDef = RTaskDef = (function() {
    var AUTOREPEAT, MULTISHOT, ONESHOT;

    RTaskDef.ONESHOT = ONESHOT = 'oneshot';

    RTaskDef.MULTISHOT = MULTISHOT = 'multishot';

    RTaskDef.AUTOREPEAT = AUTOREPEAT = 'autorepeat';

    function RTaskDef(universe, name, type, func, options) {
      var _ref, _ref1, _ref2;
      this.universe = universe;
      this.name = name;
      this.type = type;
      this.func = func;
      if (options == null) {
        options = {};
      }
      if ((_ref = this.type) !== ONESHOT && _ref !== MULTISHOT && _ref !== AUTOREPEAT) {
        throw new Error("RTaskDef: invalid type '" + this.type + "'");
      }
      this._r_id = this.universe.uniqueId(this.constructor.name, this.name);
      this.async = this.func.length === 2;
      this.multiuse = (this.type === MULTISHOT) || (this.type === AUTOREPEAT);
      this.reactive = this.type === AUTOREPEAT;
      this.autoschedule = (_ref1 = options.autoschedule) != null ? _ref1 : this.reactive;
      this.autodispose = (_ref2 = options.autodispose) != null ? _ref2 : false;
    }

    return RTaskDef;

  })();

  R.Task = RTask = (function(_super) {
    __extends(RTask, _super);

    function RTask(owner, taskDef) {
      this.taskDef = taskDef;
      this._r_detail = this.taskDef.name;
      RTask.__super__.constructor.call(this, owner);
      this.scheduledInvocation = null;
      this.runningInvocation = null;
      this.completedInvocation = null;
      if (this.taskDef.autoschedule) {
        this.schedule();
      }
    }

    RTask.prototype._disposed = function() {
      var entity, entityId, oldDependencies, _ref;
      if (this.taskDef.autoschedule && this.completedInvocation) {
        oldDependencies = ((_ref = this.completedInvocation) != null ? _ref._dependenciesById : void 0) || {};
        for (entityId in oldDependencies) {
          if (!__hasProp.call(oldDependencies, entityId)) continue;
          entity = oldDependencies[entityId];
          this.universe.subscribe(this, entity, null);
        }
      }
      return RTask.__super__._disposed.apply(this, arguments);
    };

    Object.defineProperty(RTask.prototype, 'lastResult', {
      get: function() {
        var _ref;
        return (_ref = this.completedInvocation) != null ? _ref.result : void 0;
      }
    });

    Object.defineProperty(RTask.prototype, 'lastError', {
      get: function() {
        var _ref;
        return (_ref = this.completedInvocation) != null ? _ref.error : void 0;
      }
    });

    RTask.prototype.schedule = function() {
      var task;
      if (!this.taskDef.multiuse && (this.runningInvocation || this.completedInvocation)) {
        throw new Error("Cannot reschedule a non-multiuse task");
      }
      if (!this.scheduledInvocation) {
        this.scheduledInvocation = new RTaskInvocation(this);
        this.universe.enqueue(this.taskDef, this.run.bind(this));
      }
      if (task = this.universe.currentTask) {
        task._r_addChild(this.scheduledInvocation);
      }
      return this.scheduledInvocation;
    };

    RTask.prototype.run = function() {
      this.runningInvocation = this.scheduledInvocation;
      this.scheduledInvocation = null;
      if (this.taskDef.async) {
        return this._runAsync();
      } else {
        return this._runSync();
      }
    };

    RTask.prototype._r_invocationCompleted = function() {
      var entity, entityId, newDependencies, newTopics, oldDependencies, prevInvocation;
      prevInvocation = this.completedInvocation;
      this.completedInvocation = this.runningInvocation;
      if (this.taskDef.reactive) {
        oldDependencies = (prevInvocation != null ? prevInvocation._dependenciesById : void 0) || {};
        newDependencies = this.completedInvocation._dependenciesById;
        newTopics = this.completedInvocation._topicsByDepId;
        for (entityId in oldDependencies) {
          if (!__hasProp.call(oldDependencies, entityId)) continue;
          entity = oldDependencies[entityId];
          if (!newDependencies.hasOwnProperty(entityId)) {
            this.universe.subscribe(this, entity, null);
          }
        }
        for (entityId in newDependencies) {
          if (!__hasProp.call(newDependencies, entityId)) continue;
          entity = newDependencies[entityId];
          this.universe.subscribe(this, entity, this.completedInvocation._topicsByDepId[entityId]);
        }
      }
      if (this.taskDef.autodispose) {
        return this.dispose();
      }
    };

    RTask.prototype._runSync = function() {
      var result;
      result = this.runningInvocation.domain.run(this.taskDef.func.bind(this.owner, this.owner));
      return this.runningInvocation.markComplete(null, result);
    };

    RTask.prototype._runAsync = function() {
      var err, result, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "C:\\dev\\LiveReload\\node_modules\\newreactive\\lib\\reactive.iced",
            funcname: "RTask._runAsync"
          });
          _this.runningInvocation.domain.run(_this.taskDef.func.bind(_this.owner, _this.owner, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return result = arguments[1];
              };
            })(),
            lineno: 906
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return _this.runningInvocation.markComplete(err, result);
        };
      })(this));
    };

    RTask.prototype._r_addChild = function(childInvocation) {
      if (!this.runningInvocation) {
        throw new Error("Internal error: runningInvocation is null in _r_addChild");
      }
      return this.runningInvocation.addChildInvocation(childInvocation);
    };

    RTask.prototype._r_reading = function(entity, topic) {
      if (this.taskDef.reactive) {
        return this.runningInvocation._r_addDependency(entity, topic);
      }
    };

    RTask.prototype._r_changed = function(entity, topic) {
      var _ref;
      if (this.taskDef.reactive) {
        if (topic in ((_ref = this.completedInvocation) != null ? _ref._topicsByDepId[entity._r_id] : void 0)) {
          return this.schedule();
        }
      }
    };

    return RTask;

  })(RPart);

  R.Collection = RCollection = (function(_super) {
    __extends(RCollection, _super);

    function RCollection(owner, attrSchema) {
      this.attrSchema = attrSchema;
      RCollection.__super__.constructor.call(this, owner);
      this._initialize();
      this._queries = {};
    }

    RCollection.prototype._initialize = function() {};

    RCollection.prototype.at = function(index) {
      return this.findOne({
        $at: index
      }).get();
    };

    RCollection.prototype._r_addQuery = function(query) {
      return this._queries[query._r_id] = query;
    };

    RCollection.prototype._r_removeQuery = function(query) {
      return delete this._queries[query._r_id];
    };

    return RCollection;

  })(RPart);

  R.ListCollection = RListCollection = (function(_super) {
    __extends(RListCollection, _super);

    function RListCollection() {
      return RListCollection.__super__.constructor.apply(this, arguments);
    }

    RListCollection.prototype._initialize = function() {
      RListCollection.__super__._initialize.apply(this, arguments);
      return this._items = [];
    };

    RListCollection.prototype.push = function(item) {
      return this._items.push(item);
    };

    Object.defineProperty(RListCollection.prototype, 'all', {
      get: function() {
        return new RQuery(this, RYesCondition.instance).all;
      }
    });

    RListCollection.prototype.find = function(criteria) {
      return new RQuery(this, RCondition.parse(criteria));
    };

    RListCollection.prototype.findOne = function(criteria) {
      criteria = _.extend({
        $limit: 1
      }, criteria);
      return new RSingleItemQuery(this.find(criteria));
    };

    RListCollection.prototype._r_setInitialItems = function(items) {
      var item, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        _results.push(this._items.push(item));
      }
      return _results;
    };

    RListCollection.prototype._r_all_items = function() {
      return this._items;
    };

    RListCollection.prototype._r_at = function(index) {
      return this._items[index];
    };

    RListCollection.prototype._r_updateCollection = function(items) {
      items = items.map(this._mapItem.bind(this));
      this._items.splice(0, this._items.length);
      return this._items.push.apply(this._items, items);
    };

    RListCollection.prototype._mapItem = function(item) {
      var itemEntitySchema;
      itemEntitySchema = this.attrSchema.itemType;
      if (item == null) {
        throw new Error("Null items are not allowed in collections.");
      } else if (typeof item === 'object') {
        if (item.isReactiveEntity && item.isKindOrSubclass(itemEntitySchema.kind)) {
          return item;
        } else if (item.constructor === Object) {
          return itemEntitySchema.create(this, item);
        } else {
          throw new Error("Invalid item");
        }
      } else {
        throw new Error("Invalid item type " + (typeof item));
      }
    };

    return RListCollection;

  })(RCollection);

  RSingleItemQuery = (function() {
    function RSingleItemQuery(query) {
      this.query = query;
    }

    Object.defineProperty(RSingleItemQuery.prototype, 'universe', {
      get: function() {
        return this.query.universe;
      }
    });

    RSingleItemQuery.prototype.get = function() {
      var items;
      items = this.query.all;
      switch (items.length) {
        case 0:
          return null;
        case 1:
          return items[0];
        default:
          throw new Error("More than 1 result");
      }
    };

    return RSingleItemQuery;

  })();

  RQuery = (function() {
    function RQuery(collection, condition) {
      this.collection = collection;
      this.condition = condition;
      this._r_id = this.universe.uniqueId(this.constructor.name, this.condition.toString());
      this._r_subscribers = {};
    }

    RQuery.prototype.toString = function() {
      return "RQuery< " + this.collection + " WHERE " + this.condition + " >";
    };

    Object.defineProperty(RQuery.prototype, 'universe', {
      get: function() {
        return this.collection.universe;
      }
    });

    Object.defineProperty(RQuery.prototype, 'all', {
      get: function() {
        this.universe.reading(this, 'all');
        return this.condition.obtain(this.collection);
      }
    });

    RQuery.prototype._r_subscription_started = function() {
      return this.collection._r_addQuery(this);
    };

    RQuery.prototype._r_subscription_ended = function() {
      return this.collection._r_removeQuery(this);
    };

    return RQuery;

  })();

  RCondition = (function() {
    function RCondition() {}

    RCondition.parse = function(criteria) {
      var conditions, k, v;
      conditions = [];
      if (criteria.$at != null) {
        conditions.push(new RIndexMatcher(criteria.$at));
      }
      if ((criteria.$limit != null) && (criteria.$at == null)) {
        condition.push(new RLimitCondition(criteria.$limit));
      }
      for (k in criteria) {
        v = criteria[k];
        if (!k.match(/^\$/)) {
          conditions.push(new RAttributeEqualityMatcher(k, v));
        }
      }
      switch (conditions.length) {
        case 0:
          return RYesCondition.instance;
        case 1:
          return conditions[0];
        default:
          return new RAndCondition(conditions);
      }
    };

    RCondition.prototype.canObtainEfficiently = false;

    RCondition.prototype.obtain = function(collection) {
      return this.filter(collection._r_all_items());
    };

    RCondition.prototype.filter = function(list) {
      return _.filter(list, function(item) {
        return this.matches(item);
      });
    };

    RCondition.prototype.matches = function(item) {
      return true;
    };

    return RCondition;

  })();

  RYesCondition = (function(_super) {
    __extends(RYesCondition, _super);

    function RYesCondition() {
      return RYesCondition.__super__.constructor.apply(this, arguments);
    }

    RYesCondition.prototype.toString = function() {
      return '(all)';
    };

    RYesCondition.prototype.filter = function(list) {
      return list;
    };

    RYesCondition.prototype.matches = function(item) {
      return true;
    };

    RYesCondition.instance = new RYesCondition();

    return RYesCondition;

  })(RCondition);

  RAndCondition = (function(_super) {
    __extends(RAndCondition, _super);

    function RAndCondition(conditions) {
      this.conditions = conditions;
      this._efficientObtainConditions = _.find(this.conditions, function(condition) {
        return condition.canObtainEfficiently;
      });
      this.canObtainEfficiently = this._efficientObtainConditions.length > 0;
    }

    RAndCondition.prototype.toString = function() {
      return "(and " + this.conditions.join(" ") + ")";
    };

    RAndCondition.prototype.obtain = function(collection) {
      if (this.canObtainEfficiently) {
        return this.filter(_.intersection.call(_, _.map(this._efficientObtainConditions, function(condition) {
          return condition.obtain(collection);
        })));
      } else {
        return RAndCondition.__super__.obtain.apply(this, arguments);
      }
    };

    RAndCondition.prototype.filter = function(list) {
      var condition, _i, _len, _ref;
      _ref = this.conditions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        condition = _ref[_i];
        list = condition.filter(list);
      }
      return list;
    };

    return RAndCondition;

  })(RCondition);

  RIndexCondition = (function(_super) {
    __extends(RIndexCondition, _super);

    function RIndexCondition(index) {
      this.index = index;
    }

    RIndexCondition.prototype.toString = function() {
      return "($at " + this.index + ")";
    };

    RIndexCondition.prototype.canObtainEfficiently = true;

    RIndexCondition.prototype.obtain = function(collection) {
      var result;
      if ((result = collection._r_at(this.index)) != null) {
        return [result];
      } else {
        return [];
      }
    };

    return RIndexCondition;

  })(RCondition);

  RLimitCondition = (function(_super) {
    __extends(RLimitCondition, _super);

    function RLimitCondition(limit) {
      this.limit = limit;
    }

    RLimitCondition.prototype.toString = function() {
      return "($limit " + this.limit + ")";
    };

    RLimitCondition.prototype.filter = function(list) {
      if (list.length > this.limit) {
        return list.slice(0, this.limit);
      } else {
        return list;
      }
    };

    return RLimitCondition;

  })(RCondition);

  RAttributeEqualityCondition = (function(_super) {
    __extends(RAttributeEqualityCondition, _super);

    function RAttributeEqualityCondition(attrName, value) {
      this.attrName = attrName;
      this.value = value;
    }

    RAttributeEqualityCondition.prototype.toString = function() {
      return "(." + this.attrName + " == " + this.value + ")";
    };

    RAttributeEqualityCondition.prototype.matches = function(item) {
      return item[this.attrName] === this.value;
    };

    return RAttributeEqualityCondition;

  })(RCondition);

  RDummyEntity = (function() {
    function RDummyEntity() {}

    return RDummyEntity;

  })();

  RDuckType = (function() {
    RDuckType.prototype.isTypeDescriptor = true;

    RDuckType.prototype.isDuckTypeDescriptor = true;

    function RDuckType(name, requirements) {
      this.name = name;
      this.requirements = requirements;
    }

    RDuckType.prototype.toString = function() {
      return "" + this.name + "-Quack";
    };

    RDuckType.prototype.coerce = function(value) {
      var k, missing, v, _ref;
      if (value != null) {
        if (typeof value !== 'object') {
          throw new Error("Invalid " + (typeof value) + " value, expected a " + this.name + "-like object");
        }
        missing = null;
        _ref = this.requirements;
        for (k in _ref) {
          v = _ref[k];
          if (value[k] !== v) {
            missing || (missing = {});
            missing[k] = v;
          }
        }
        if (missing) {
          throw new Error("Invalid " + value.constructor.name + " value, expected a " + this.name + "-like object, missing the following keys: " + (JSON.stringify(missing)));
        }
      }
      return value;
    };

    RDuckType.prototype.defaultValue = function() {
      throw new Error("Type " + this + " does not have a default value");
    };

    return RDuckType;

  })();

}).call(this);
