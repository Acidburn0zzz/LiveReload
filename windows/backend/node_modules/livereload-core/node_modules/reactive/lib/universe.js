// Generated by IcedCoffeeScript 1.3.3f
(function() {
  var EventEmitter, RModel, RModelSchema, RUniverse, debug,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  debug = require('debug')('reactive');

  EventEmitter = require('events').EventEmitter;

  RModel = require('./model');

  RModelSchema = require('./schema');

  RUniverse = (function(_super) {

    __extends(RUniverse, _super);

    function RUniverse() {
      this._changedModels = [];
      this._scheduled = false;
      this._completionFuncs = [];
      this._blocks = [];
      this._blocksById = {};
      this._nextOrdinal = {};
      this._modelSchemas = {};
      this.currentCollector = null;
      this._processPendingChanges = this._processPendingChanges.bind(this);
      if (RModel.prototype.universe) RModel.prototype.universe.destroy();
      RModel.prototype.universe = this;
    }

    RUniverse.prototype.destroy = function() {
      if (RModel.prototype.universe === this) {
        return RModel.prototype.universe = null;
      }
    };

    RUniverse.prototype.then = function(func) {
      this._completionFuncs.push(func);
      return this._scheduleChangeProcessing();
    };

    RUniverse.prototype.uniqueId = function(className, detail) {
      var ordinal, _base;
      detail = detail ? ('_' + detail).replace(/[^0-9a-zA-Z]+/g, '_') : '';
      (_base = this._nextOrdinal)[className] || (_base[className] = 0);
      ordinal = this._nextOrdinal[className]++;
      return "" + className + ordinal + detail;
    };

    RUniverse.prototype.dependency = function(model, attribute) {
      var _ref;
      return (_ref = this.currentCollector) != null ? _ref.dependency(model, attribute) : void 0;
    };

    RUniverse.prototype.mixin = function() {
      var mixinClasses, modelClass, _ref;
      modelClass = arguments[0], mixinClasses = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref = this.modelSchema(modelClass)).mixin.apply(_ref, mixinClasses);
    };

    RUniverse.prototype.create = function(modelClass, options) {
      if (options == null) options = {};
      return this.modelSchema(modelClass).create(options);
    };

    RUniverse.prototype.modelSchema = function(modelClass) {
      var _base, _name;
      if (!modelClass.name) {
        throw new Error("R.Universe require model classes to have a .name");
      }
      return (_base = this._modelSchemas)[_name = modelClass.name] || (_base[_name] = new RModelSchema(this, modelClass));
    };

    RUniverse.prototype._internal_modelChanged = function(model) {
      this._changedModels.push(model);
      return this._scheduleChangeProcessing();
    };

    RUniverse.prototype._internal_scheduleBlock = function(block) {
      var bid;
      bid = block._id;
      if (!this._blocksById.hasOwnProperty(bid)) {
        this._blocksById[bid] = true;
        this._blocks.push(block);
      }
      return this._scheduleChangeProcessing();
    };

    RUniverse.prototype._processPendingChanges = function() {
      var attr, attrs, block, func, model, subscriber, value, _i, _len, _ref;
      while ((this._changedModels.length > 0) || (this._blocks.length > 0) || (this._completionFuncs.length > 0)) {
        while (model = this._changedModels.shift()) {
          attrs = model._internal_startProcessingChanges();
          for (attr in attrs) {
            value = attrs[attr];
            debug("Change: " + model + "." + attr + " is now " + (model.get(attr)));
            this.emit('change', model, attr);
            _ref = model.subscribersTo(attr);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              subscriber = _ref[_i];
              this._internal_scheduleBlock(subscriber);
            }
          }
        }
        while (block = this._blocks.shift()) {
          delete this._blocksById[block._id];
          block.execute();
          if (this._changedModels.length > 0) break;
        }
        while (func = this._completionFuncs.shift()) {
          func();
          if ((this._changedModels.length > 0) || (this._blocks.length > 0)) break;
        }
      }
      return this._scheduled = false;
    };

    RUniverse.prototype._scheduleChangeProcessing = function() {
      if (!this._scheduled) {
        process.nextTick(this._processPendingChanges);
        return this._scheduled = true;
      }
    };

    return RUniverse;

  })(EventEmitter);

  module.exports = RUniverse;

}).call(this);
