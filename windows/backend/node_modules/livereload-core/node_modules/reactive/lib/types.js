// Generated by IcedCoffeeScript 1.3.3f
(function() {
  var ArrayType, ObjectType, StdTypes, resolve;

  ArrayType = (function() {

    ArrayType.prototype.isTypeDescriptor = true;

    function ArrayType(elemType) {
      this.elemType = elemType;
    }

    ArrayType.prototype.toString = function() {
      return "{ array: " + this.elemType + " }";
    };

    ArrayType.prototype.defaultValue = function() {
      return [];
    };

    ArrayType.prototype.coerce = function(value) {
      var elem, _i, _len, _results;
      if (!Array.isArray(value)) {
        throw new Error("Value is not an array: " + JSON.stringify(value));
      }
      if (this.elemType === StdTypes.any) {
        return value.slice(0);
      } else {
        _results = [];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          elem = value[_i];
          _results.push(this.elemType.coerce(elem));
        }
        return _results;
      }
    };

    return ArrayType;

  })();

  ObjectType = (function() {

    ObjectType.prototype.isTypeDescriptor = true;

    function ObjectType(_class) {
      this["class"] = _class;
      if (!this["class"].name) {
        throw new Error("Only classes with a .name can be used for type checking");
      }
    }

    ObjectType.prototype.toString = function() {
      return "{ object: " + this["class"].name + " }";
    };

    ObjectType.prototype.coerce = function(value) {
      if (value != null) {
        if (typeof value !== 'object') {
          throw new Error("Invalid " + (typeof value) + " value, expected " + this["class"].name);
        }
        if (!(value instanceof this["class"])) {
          throw new Error("Invalid " + (value.constructor.name || 'object') + " value, expected " + this["class"].name);
        }
      }
      return value;
    };

    ObjectType.prototype.defaultValue = function() {
      return null;
    };

    return ObjectType;

  })();

  StdTypes = {
    any: {
      isTypeDescriptor: true,
      coerce: function(value) {
        return value;
      },
      toString: function() {
        return 'any';
      },
      defaultValue: function() {
        return null;
      }
    },
    string: {
      isTypeDescriptor: true,
      coerce: function(value) {
        if (value != null) {
          return "" + value;
        } else {
          return null;
        }
      },
      toString: function() {
        return 'string';
      },
      defaultValue: function() {
        return '';
      }
    },
    int: {
      isTypeDescriptor: true,
      coerce: function(value) {
        return ~~value;
      },
      toString: function() {
        return 'int';
      },
      defaultValue: function() {
        return 0;
      }
    },
    number: {
      isTypeDescriptor: true,
      coerce: function(value) {
        return +value;
      },
      toString: function() {
        return 'number';
      },
      defaultValue: function() {
        return 0;
      }
    },
    boolean: {
      isTypeDescriptor: true,
      coerce: function(value) {
        return !!value;
      },
      toString: function() {
        return 'boolean';
      },
      defaultValue: function() {
        return false;
      }
    }
  };

  StdTypes.array = new ArrayType(StdTypes.any);

  exports.resolve = resolve = function(type) {
    var keys;
    if (!(type != null)) {
      return StdTypes.any;
    } else if (type.isTypeDescriptor) {
      return type;
    } else {
      switch (typeof type) {
        case 'string':
          return StdTypes[type] || (function() {
            throw new Error("Unknown type name " + type);
          })();
        case 'object':
          if (type.constructor === Object) {
            keys = Object.keys(type);
            if ((keys.length === 1) && (keys[0] === 'array')) {
              return new ArrayType(resolve(type.array));
            } else if ((keys.length === 1) && (keys[0] === 'object')) {
              return new ObjectType(type.object);
            } else {
              throw new Error("Unsupported type declaration " + type);
            }
          } else {
            throw new Error("Unsupported type declaration " + type);
          }
          break;
        case 'function':
          if (type === String) {
            return StdTypes.string;
          } else if (type === Array) {
            return StdTypes.array;
          } else if (type === Boolean) {
            return StdTypes.boolean;
          } else if (type === Number) {
            return StdTypes.number;
          } else if (type === Object) {
            return StdTypes.any;
          } else {
            return new ObjectType(type);
          }
      }
    }
  };

  exports.coerce = function(value, type) {
    return resolve(type).coerce(value);
  };

}).call(this);
