// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var MessageFormat,
    __slice = [].slice;

  module.exports = MessageFormat = (function() {
    MessageFormat.WILDCARDS = {
      file: '[^\\n]+?',
      line: '\\d+',
      message: '\\S[^\\n]+?'
    };

    function MessageFormat(pattern, createMessage) {
      var index;
      this.pattern = pattern;
      this.createMessage = createMessage != null ? createMessage : (function() {
        return {};
      });
      this.indices = {};
      this.overrides = {};
      this.used = false;
      if (typeof this.pattern === 'string') {
        this.options = {};
      } else {
        this.options = this.pattern;
        this.pattern = this.options.pattern;
        if (typeof this.pattern !== 'string') {
          throw new Error("When an error/warning pattern is specified as an object, it must contain a string 'pattern' key; got: " + (JSON.stringify(this.options, null, 2)));
        }
      }
      if (this.options.message) {
        this.overrides.message = this.options.message;
      }
      index = 1;
      this.processedPattern = this.pattern.replace(/<ESC>/g, '').replace(/\(\(([\w-]+)(?::(.*?))?\)\)/gm, (function(_this) {
        return function(_, name, content) {
          var replacement;
          if (replacement = MessageFormat.WILDCARDS[name]) {
            _this.indices[name] = index;
          } else {
            throw new Error("Unknown wildcard: '" + name + "'");
          }
          index++;
          if (content) {
            content = content.replace('***', replacement);
            return "(" + content + ")";
          } else {
            return "(" + replacement + ")";
          }
        };
      })(this));
      this.regexp = new RegExp(this.processedPattern, 'ig');
    }

    MessageFormat.prototype.scan = function(text) {
      var messages;
      messages = [];
      text.replace(this.regexp, (function(_this) {
        return function() {
          var index, key, match, message, value, _ref, _ref1;
          match = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          message = _this.createMessage();
          _ref = _this.indices;
          for (key in _ref) {
            index = _ref[key];
            message[key] = match[index];
          }
          _ref1 = _this.overrides;
          for (key in _ref1) {
            value = _ref1[key];
            message[key] = value.replace('***', message[key] || '');
          }
          messages.push(message);
          return "";
        };
      })(this));
      return {
        text: text,
        messages: messages
      };
    };

    return MessageFormat;

  })();

}).call(this);
