// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  var DefaultWebSocketPort, EventEmitter, LRWebSocketConnection, LRWebSocketServer, Url, debug, fs, http, wsio,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  debug = require('debug')('livereload:server');

  wsio = require('websocket.io');

  http = require('http');

  Url = require('url');

  fs = require('fs');

  EventEmitter = require('events').EventEmitter;

  LRWebSocketConnection = require('./connection');

  DefaultWebSocketPort = parseInt(process.env['LRPortOverride'], 10) || 35729;

  LRWebSocketServer = (function(_super) {
    __extends(LRWebSocketServer, _super);

    function LRWebSocketServer(options) {
      var _base;
      this.options = options;
      if (!this.options.id) {
        throw new Error("ERR_INVALID_ARG: id is required");
      }
      if (!this.options.name) {
        throw new Error("ERR_INVALID_ARG: name is required");
      }
      if (!this.options.version) {
        throw new Error("ERR_INVALID_ARG: version is required");
      }
      this.port = this.options.port || DefaultWebSocketPort;
      this.connections = {};
      this.activeConnections = 0;
      this.nextConnectionId = 1;
      if ((_base = this.options).protocols == null) {
        _base.protocols = {};
      }
    }

    LRWebSocketServer.prototype.listen = function(callback) {
      var callbackCalled, e;
      callbackCalled = false;
      this.httpServer = http.createServer();
      try {
        this.httpServer.on('error', function(err) {
          if (!callbackCalled) {
            callbackCalled = true;
            return callback(err);
          } else {
            throw err;
          }
        });
        return this.httpServer.listen(this.port, (function(_this) {
          return function(err) {
            if (err) {
              callbackCalled = true;
              return callback(err);
            }
            _this.httpServer.on('request', function(request, response) {
              request.on('data', function() {});
              return request.on('end', function() {
                var url;
                url = Url.parse(request.url, true);
                if (url.pathname === '/livereload.js' || url.pathname === '/xlivereload.js') {
                  return _this.emit('livereload.js', request, response);
                } else {
                  return _this.emit('httprequest', url, request, response);
                }
              });
            });
            _this.wsserver = wsio.attach(_this.httpServer);
            _this.wsserver.on('connection', function(socket) {
              return _this._createConnection(socket);
            });
            return callback(null);
          };
        })(this));
      } catch (_error) {
        e = _error;
        return callback(e);
      }
    };

    LRWebSocketServer.prototype.close = function() {
      var connection, _, _ref;
      this.httpServer.close();
      _ref = this.connections;
      for (_ in _ref) {
        if (!__hasProp.call(_ref, _)) continue;
        connection = _ref[_];
        connection.close();
      }
    };

    LRWebSocketServer.prototype.monitoringConnections = function() {
      var connection, dummy, _ref, _results;
      _ref = this.connections;
      _results = [];
      for (dummy in _ref) {
        if (!__hasProp.call(_ref, dummy)) continue;
        connection = _ref[dummy];
        if (connection.isMonitoring()) {
          _results.push(connection);
        }
      }
      return _results;
    };

    LRWebSocketServer.prototype.monitoringConnectionCount = function() {
      return this.monitoringConnections().length;
    };

    LRWebSocketServer.prototype._createConnection = function(socket) {
      var connection;
      connection = new LRWebSocketConnection(socket, "C" + (this.nextConnectionId++), this.options);
      connection.on('connected', (function(_this) {
        return function() {
          _this.connections[connection.id] = connection;
          return _this.emit('connected', connection);
        };
      })(this));
      connection.on('disconnected', (function(_this) {
        return function() {
          delete _this.connections[connection.id];
          return _this.emit('disconnected', connection);
        };
      })(this));
      connection.on('command', (function(_this) {
        return function(command) {
          return _this.emit('command', connection, command);
        };
      })(this));
      connection.on('error', (function(_this) {
        return function(err) {
          return _this.emit('error', err, connection);
        };
      })(this));
      return connection;
    };

    return LRWebSocketServer;

  })(EventEmitter);

  module.exports = LRWebSocketServer;

}).call(this);
