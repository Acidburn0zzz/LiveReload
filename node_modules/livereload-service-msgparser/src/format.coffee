ANSI_ESCAPE_RE = ///
  (?:                   # one or more ANSI escape sequences:
    \x1b                #   1) two-byte sequence: ESC <trailer>
    [@A-Z\\\]^_]        #      where <trailer> is ASCII 64 to 95 (@ to _), except for [
  |
    (?:                 #   2) multi-byte sequence that starts with CSI, Control Sequence Introducer
      \x1b \[           #        a) two-character CSI -- ESC [
    |
      \x9B              #        b) single-character CSI (less often used, but valid)
    )
    .*?                 #        followed by some arguments
    [@-~]               #        followed by <terminator>, ASCII 64 to 126 (@ to ~)
  )+
///g

BETTER_ESC_CHAR = '\u241B' # Unicode char for displaying ESC (␛)
BETTER_ESC_CHAR_RE = /\u241B/g


module.exports =
class MessageFormat

  @WILDCARDS =
    file:    '[^\\n]+?'
    line:    '\\d+'
    column:  '\\d+'
    message: '\\S[^\\n]+?'

  constructor: (@pattern, @createMessage=(-> {})) ->
    @indices   = {}
    @overrides = {}
    @used      = no

    if typeof @pattern is 'string'
      @options = {}
    else
      @options = @pattern
      @pattern = @options.pattern
      unless typeof @pattern is 'string'
        throw new Error "When an error/warning pattern is specified as an object, it must contain a string 'pattern' key; got: #{JSON.stringify(@options, null, 2)}"

    if @options.message
      @overrides.message = @options.message

    @processedPattern = @pattern
    if @processedPattern.match(/<ESC>/)
      @matchEscapes = yes
      @processedPattern = @processedPattern.replace(/<ESC>/g, BETTER_ESC_CHAR)
    else
      @matchEscapes = no

    index = 1
    @processedPattern = @processedPattern.replace /// \(\( ([\w-]+) (?: : (.*?) )? \)\) ///gm, (_, name, content) =>
      if replacement = MessageFormat.WILDCARDS[name]
        @indices[name] = index
      else
        throw new Error("Unknown wildcard: '#{name}'")
      index++

      if content
        content = content.replace '***', replacement
        return "(#{content})"
      else
        return "(#{replacement})"

    # console.log @pattern
    # console.log @processedPattern
    @regexp = new RegExp(@processedPattern, 'ig')

  scan: (text) ->
    messages = []

    if @matchEscapes
      text = text.replace(ANSI_ESCAPE_RE, BETTER_ESC_CHAR)
    else
      text = text.replace(ANSI_ESCAPE_RE, '')

    # console.log "Matching %j", text
    # console.log "against %j", @processedPattern

    text = text.replace @regexp, (match...) =>

      # console.log @pattern
      # console.log @processedPattern
      # console.log @indices
      # console.log match

      message = @createMessage()
      for key, index of @indices
        value = match[index] || ''
        if @matchEscapes
          value = value.replace(BETTER_ESC_CHAR_RE, '')
        message[key] = value
      for key, value of @overrides
        message[key] = value.replace('***', message[key] || '')
      messages.push message

      ""

    { text, messages }
