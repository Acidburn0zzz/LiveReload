soa = require('livereload-soa')
fs = require('fs')
Path = require('path')
LRWebSocketServer = require('livereload-server')
urloverride = require('./urloverride')

class ServerService extends soa.ServiceImpl

  constructor: (carrier, options) ->
    super(carrier, options)
    @refreshCount = 0
    @urlOverrideCoordinator = new urloverride.URLOverrideCoordinator()

  on_init: (command, callback) ->
    @appVersion = command.appVersion

    @server = new LRWebSocketServer({
      port: +process.env['LRPortOverride'] || null,
      protocols: { saving: 1 },
      id: "com.livereload.LiveReload",
      name: "LiveReload",
      version: @appVersion
    })

    @server.on('connected',     @_connectionCountChanged.bind(this))
    @server.on('disconnected',  @_connectionCountChanged.bind(this))
    @server.on('command',       @_handleIncomingCommand.bind(this))
    @server.on('httprequest',   @_onhttprequest.bind(this))
    @server.on('livereload.js', @_serveLiveReloadJs.bind(this))
    @server.on('error',         @_handleServerError.bind(this))

    @server.listen (err) =>
      if err?.code == 'EADDRINUSE'
        @send({ service: 'kernel', command: 'on-port-occupied-error', port: @server.port })
        return callback(null)
      if err
        return callback(err)

      @_log('info', "WebSocket server listening on port " + @server.port + ".")

      @_connectionCountChanged()
      @_refreshCountChanged()

      callback(null)

  on_reload: (command, callback) ->
    command.messages.forEach((message) => @_reload(message))

  dispose: (callback) ->
    if !@server
      return callback(null)

    @_log('info', "WebSocket server shutting down...")
    @server.close()
    @server = null
    setTimeout(@_disposeDone.bind(this, callback), 20)

  _disposeDone: (callback) ->
    @_log('verbose', "WebSocket server closed.")
    callback(null)

  _reload: (message) ->
    if message.enableOverride and message.localPath and @urlOverrideCoordinator.shouldOverrideFile(message.localPath)
      message.overrideURL = @urlOverrideCoordinator.createOverrideURL(message.localPath)

    delete message.enableOverride
    delete message.localPath

    @server.monitoringConnections().forEach((c) => c.send(message))

    @refreshCount++
    @_refreshCountChanged()

  _handleIncomingCommand: (connection, message) ->
    @_log('verbose', "Ignoring incoming browser notification: " + JSON.stringify(message))

  _connectionCountChanged: ->
    @send({ service: 'kernel', command: 'server-connection-count-changed', connectionCount: @server.monitoringConnectionCount() })

  _refreshCountChanged: ->
    @send({ service: 'kernel', command: 'server-refresh-count-changed', refreshCount: @refreshCount })

  _serveLiveReloadJs: (req, res) ->
    @_log('verbose', "Serving livereload.js to the browser.")
    fs.readFile Path.join(__dirname, '../res/livereload.js'), 'utf8', (err, data) =>
      throw err if err
      res.writeHead(200, { 'Content-Length': data.length, 'Content-Type': 'text/javascript' })
      res.end(data)

  _onhttprequest: (url, request, response) ->
    @urlOverrideCoordinator.handleHttpRequest url, (err, result) =>
      if err
        @_log 'warn', "Failed URL override request (err: #{err}). Please try reload the browser page."
        if err == urloverride.ERR_NOT_MATCHED
          response.writeHead(404)
          response.end()
        else if err == urloverride.ERR_AUTH_FAILED
          response.writeHead(403)
          response.end("LiveReload cannot authenticate this request please reload the page. (Happens if you restart LiveReload app.)")
        else if err == urloverride.ERR_FILE_NOT_FOUND
          response.writeHead(404)
          response.end("The given file no longer exists. Please reload the page.")
        else
          response.writeHead(500)
          response.end("Error processing this request. Please see the log file, and try reloading this page.")
      else
        response.setHeader('Content-Type', result.mime)
        response.setHeader('Content-Length', result.content.length)
        response.end(result.content)

  _handleServerError: () ->
    # TODO: other errors?
    @send { service: 'kernel', command: 'on-browser-v6-protocol-connection' }

  _log: (level, text) ->
    @send { service: 'kernel', command: 'log', level: level, text: text }


module.exports = (carrier, options={}) ->
  options.name or= 'server'
  return new ServerService(carrier, options)
