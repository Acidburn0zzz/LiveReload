(function() {
  var CSSFileType, CSS_IMPORT_RE, ERR_AUTH_FAILED, ERR_FILE_NOT_FOUND, ERR_NOT_MATCHED, FileType, FileTypeByExtension, ImageFileType, Path, PathAuthenticator, URLOverrideCoordinator, Url, crypto, fs, lookupFileType, random40, random8;

  fs = require('fs');

  Path = require('path');

  Url = require('url');

  ERR_NOT_MATCHED = 'not-matched';

  ERR_FILE_NOT_FOUND = 'file-not-found';

  ERR_AUTH_FAILED = 'auth-failed';

  FileType = (function() {
    function FileType() {
      this.overridable = false;
      this.mime = "application/octet-stream";
      this.encoding = null;
    }

    return FileType;

  })();

  CSSFileType = (function() {
    function CSSFileType() {
      this.overridable = true;
      this.mime = "text/css";
      this.isCSS = true;
      this.encoding = 'utf8';
    }

    return CSSFileType;

  })();

  ImageFileType = (function() {
    function ImageFileType(mime) {
      this.mime = mime;
      this.overridable = true;
    }

    return ImageFileType;

  })();

  FileTypeByExtension = {
    '.css': new CSSFileType(),
    '.png': new ImageFileType('image/png'),
    '.jpg': new ImageFileType('image/jpg'),
    '.jpeg': new ImageFileType('image/jpg'),
    '.gif': new ImageFileType('image/gif')
  };

  lookupFileType = function(path) {
    var ext, _ref;
    ext = Path.extname(path);
    return (_ref = FileTypeByExtension[ext]) != null ? _ref : new FileType();
  };

  CSS_IMPORT_RE = /(url\s*\(\s*?['"]?)([^)'"]*)(['"]?\s*?\))/g;

  URLOverrideCoordinator = (function() {
    function URLOverrideCoordinator() {
      this.authenticator = new PathAuthenticator();
      this.fs = require('fs');
      this.Path = require('path');
    }

    URLOverrideCoordinator.prototype.shouldOverrideFile = function(path) {
      return lookupFileType(path).overridable;
    };

    URLOverrideCoordinator.prototype.createOverrideURL = function(path) {
      return this.authenticator.urlPathForServingLocalPath(path);
    };

    URLOverrideCoordinator.prototype.handleHttpRequest = function(url, callback) {
      var baseUrl, content, err, errCode, exists, fileType, localPath, _ref, _ref1;
      _ref = this.authenticator.localPathForUrlPath(url.pathname), errCode = _ref[0], localPath = _ref[1];
      if (errCode === 404) {
        return callback(ERR_NOT_MATCHED);
      }
      if (errCode === 403) {
        return callback(ERR_AUTH_FAILED);
      }
      if (errCode !== 200) {
        return callback(errCode);
      }
      exists = this.Path.existsSync(localPath);
      if (!exists) {
        return callback(ERR_FILE_NOT_FOUND);
      }
      baseUrl = (_ref1 = url.query) != null ? _ref1.url : void 0;
      fileType = lookupFileType(localPath);
      try {
        content = this.fs.readFileSync(localPath, fileType.encoding);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
      if (fileType.isCSS && baseUrl) {
        content = content.replace(CSS_IMPORT_RE, function(match, prefix, importedURL, suffix) {
          var newURL;
          newURL = Url.resolve(baseUrl, importedURL);
          return "" + prefix + newURL + suffix;
        });
      }
      return callback(null, {
        mime: fileType.mime,
        content: content
      });
    };

    return URLOverrideCoordinator;

  })();

  module.exports = {
    URLOverrideCoordinator: URLOverrideCoordinator,
    ERR_NOT_MATCHED: ERR_NOT_MATCHED,
    ERR_AUTH_FAILED: ERR_AUTH_FAILED,
    ERR_FILE_NOT_FOUND: ERR_FILE_NOT_FOUND
  };

  crypto = require('crypto');

  random8 = function() {
    return Math.random().toString(36).substr(2, 8);
  };

  random40 = function() {
    return random8() + random8() + random8() + random8() + random8();
  };

  PathAuthenticator = (function() {
    function PathAuthenticator() {
      this.salt = random40();
    }

    PathAuthenticator.prototype.sign = function(localPath) {
      return crypto.createHmac('sha1', this.salt).update(localPath).digest('hex');
    };

    PathAuthenticator.prototype.urlPathForServingLocalPath = function(localPath) {
      var signature;
      if (localPath.length === 0 || localPath[0] !== '/') {
        throw new Error("urlPathForServingLocalPath: localPath is expected to start with a slash: '" + localPath + "'");
      }
      signature = this.sign(localPath);
      return "/_livereload/url-override-v1/" + signature + localPath;
    };

    PathAuthenticator.prototype.localPathForUrlPath = function(urlPath) {
      var localPath, m, signature, _;
      if (m = urlPath.match(/^\/_livereload\/url-override-v1\/([a-z0-9]{40})(\/.*)$/)) {
        _ = m[0], signature = m[1], localPath = m[2];
        localPath = decodeURI(localPath);
        if (this.sign(localPath) === signature) {
          return [200, localPath];
        } else {
          return [403];
        }
      }
      return [404];
    };

    return PathAuthenticator;

  })();

}).call(this);
