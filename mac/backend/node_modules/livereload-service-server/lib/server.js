(function() {
  var LRWebSocketServer, Path, ServerService, fs, soa, urloverride,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  soa = require('livereload-soa');

  fs = require('fs');

  Path = require('path');

  LRWebSocketServer = require('livereload-server');

  urloverride = require('./urloverride');

  ServerService = (function(_super) {
    __extends(ServerService, _super);

    function ServerService(carrier, options) {
      ServerService.__super__.constructor.call(this, carrier, options);
      this.refreshCount = 0;
      this.urlOverrideCoordinator = new urloverride.URLOverrideCoordinator();
    }

    ServerService.prototype.on_init = function(command, callback) {
      var _this = this;
      this.appVersion = command.appVersion;
      this.server = new LRWebSocketServer({
        port: +process.env['LRPortOverride'] || null,
        protocols: {
          saving: 1
        },
        id: "com.livereload.LiveReload",
        name: "LiveReload",
        version: this.appVersion
      });
      this.server.on('connected', this._connectionCountChanged.bind(this));
      this.server.on('disconnected', this._connectionCountChanged.bind(this));
      this.server.on('command', this._handleIncomingCommand.bind(this));
      this.server.on('httprequest', this._onhttprequest.bind(this));
      this.server.on('livereload.js', this._serveLiveReloadJs.bind(this));
      this.server.on('error', this._handleServerError.bind(this));
      return this.server.listen(function(err) {
        if ((err != null ? err.code : void 0) === 'EADDRINUSE') {
          _this.send({
            service: 'kernel',
            command: 'on-port-occupied-error',
            port: _this.server.port
          });
          return callback(null);
        }
        if (err) {
          return callback(err);
        }
        _this._log('info', "WebSocket server listening on port " + _this.server.port + ".");
        _this._connectionCountChanged();
        _this._refreshCountChanged();
        return callback(null);
      });
    };

    ServerService.prototype.on_reload = function(command, callback) {
      var _this = this;
      return command.messages.forEach(function(message) {
        return _this._reload(message);
      });
    };

    ServerService.prototype.dispose = function(callback) {
      if (!this.server) {
        return callback(null);
      }
      this._log('info', "WebSocket server shutting down...");
      this.server.close();
      this.server = null;
      return setTimeout(this._disposeDone.bind(this, callback), 20);
    };

    ServerService.prototype._disposeDone = function(callback) {
      this._log('verbose', "WebSocket server closed.");
      return callback(null);
    };

    ServerService.prototype._reload = function(message) {
      var _this = this;
      if (message.enableOverride && message.localPath && this.urlOverrideCoordinator.shouldOverrideFile(message.localPath)) {
        message.overrideURL = this.urlOverrideCoordinator.createOverrideURL(message.localPath);
      }
      delete message.enableOverride;
      delete message.localPath;
      this.server.monitoringConnections().forEach(function(c) {
        return c.send(message);
      });
      this.refreshCount++;
      return this._refreshCountChanged();
    };

    ServerService.prototype._handleIncomingCommand = function(connection, message) {
      return this._log('verbose', "Ignoring incoming browser notification: " + JSON.stringify(message));
    };

    ServerService.prototype._connectionCountChanged = function() {
      return this.send({
        service: 'kernel',
        command: 'server-connection-count-changed',
        connectionCount: this.server.monitoringConnectionCount()
      });
    };

    ServerService.prototype._refreshCountChanged = function() {
      return this.send({
        service: 'kernel',
        command: 'server-refresh-count-changed',
        refreshCount: this.refreshCount
      });
    };

    ServerService.prototype._serveLiveReloadJs = function(req, res) {
      var _this = this;
      this._log('verbose', "Serving livereload.js to the browser.");
      return fs.readFile(Path.join(__dirname, '../res/livereload.js'), 'utf8', function(err, data) {
        if (err) {
          throw err;
        }
        res.writeHead(200, {
          'Content-Length': data.length,
          'Content-Type': 'text/javascript'
        });
        return res.end(data);
      });
    };

    ServerService.prototype._onhttprequest = function(url, request, response) {
      var _this = this;
      return this.urlOverrideCoordinator.handleHttpRequest(url, function(err, result) {
        if (err) {
          _this._log('warn', "Failed URL override request (err: " + err + "). Please try reload the browser page.");
          if (err === urloverride.ERR_NOT_MATCHED) {
            response.writeHead(404);
            return response.end();
          } else if (err === urloverride.ERR_AUTH_FAILED) {
            response.writeHead(403);
            return response.end("LiveReload cannot authenticate this request please reload the page. (Happens if you restart LiveReload app.)");
          } else if (err === urloverride.ERR_FILE_NOT_FOUND) {
            response.writeHead(404);
            return response.end("The given file no longer exists. Please reload the page.");
          } else {
            response.writeHead(500);
            return response.end("Error processing this request. Please see the log file, and try reloading this page.");
          }
        } else {
          response.setHeader('Content-Type', result.mime);
          response.setHeader('Content-Length', result.content.length);
          return response.end(result.content);
        }
      });
    };

    ServerService.prototype._handleServerError = function() {
      return this.send({
        service: 'kernel',
        command: 'on-browser-v6-protocol-connection'
      });
    };

    ServerService.prototype._log = function(level, text) {
      return this.send({
        service: 'kernel',
        command: 'log',
        level: level,
        text: text
      });
    };

    return ServerService;

  })(soa.ServiceImpl);

  module.exports = function(carrier, options) {
    if (options == null) {
      options = {};
    }
    options.name || (options.name = 'server');
    return new ServerService(carrier, options);
  };

}).call(this);
